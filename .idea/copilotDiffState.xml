<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="updatedContent" value="# Build directories&#10;build/&#10;cmake-build-*/&#10;*.build/&#10;&#10;# CMake files&#10;CMakeCache.txt&#10;CMakeFiles/&#10;cmake_install.cmake&#10;Makefile&#10;*.cmake&#10;!CMakeLists.txt&#10;&#10;# Generated files&#10;*.o&#10;*.so&#10;*.a&#10;*.dylib&#10;*.dll&#10;*.exe&#10;moc_*.cpp&#10;*.moc&#10;ui_*.h&#10;qrc_*.cpp&#10;&#10;# IDE files&#10;.idea/&#10;.vscode/&#10;*.user&#10;*.pro.user*&#10;*.tmp&#10;&#10;# Qt specific&#10;*.qm&#10;.qmake.stash&#10;&#10;# System files&#10;.DS_Store&#10;Thumbs.db&#10;*~&#10;&#10;# Temporary files&#10;*.tmp&#10;*.temp&#10;*.log&#10;&#10;# Autogenerated&#10;*_autogen/" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.20)&#10;project(PomodoroTimer VERSION 0.1.1 LANGUAGES CXX)&#10;&#10;# Set C++ standard&#10;set(CMAKE_CXX_STANDARD 17)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;set(CMAKE_CXX_EXTENSIONS OFF)&#10;&#10;# Find Qt6&#10;find_package(Qt6 REQUIRED COMPONENTS Core Widgets)&#10;qt6_standard_project_setup()&#10;&#10;# Include directories&#10;include_directories(src/core)&#10;include_directories(src/ui)&#10;include_directories(src/system)&#10;include_directories(src/utils)&#10;&#10;# Define source files with new structure&#10;set(CORE_HEADERS&#10;    src/core/TimerState.h&#10;    src/core/TimerController.h&#10;    src/core/PomodoroConfig.h&#10;)&#10;&#10;set(UI_HEADERS&#10;    src/ui/PomodoroTimer.h&#10;    src/ui/CircularProgressBar.h&#10;    src/ui/SettingsDialog.h&#10;    src/ui/StatisticsDialog.h&#10;)&#10;&#10;set(SYSTEM_HEADERS&#10;    src/system/SystemTrayManager.h&#10;    src/system/KeyboardShortcuts.h&#10;    src/system/NotificationManager.h&#10;)&#10;&#10;set(CORE_SOURCES&#10;    src/core/TimerState.cpp&#10;    src/core/TimerController.cpp&#10;    src/core/PomodoroConfig.cpp&#10;)&#10;&#10;set(UI_SOURCES&#10;    src/ui/PomodoroTimer.cpp&#10;    src/ui/CircularProgressBar.cpp&#10;    src/ui/SettingsDialog.cpp&#10;    src/ui/StatisticsDialog.cpp&#10;)&#10;&#10;set(SYSTEM_SOURCES&#10;    src/system/SystemTrayManager.cpp&#10;    src/system/KeyboardShortcuts.cpp&#10;    src/system/NotificationManager.cpp&#10;)&#10;&#10;set(ALL_HEADERS ${CORE_HEADERS} ${UI_HEADERS} ${SYSTEM_HEADERS})&#10;set(ALL_SOURCES main.cpp ${CORE_SOURCES} ${UI_SOURCES} ${SYSTEM_SOURCES})&#10;&#10;# Create executable&#10;qt6_add_executable(${PROJECT_NAME} ${ALL_SOURCES} ${ALL_HEADERS})&#10;&#10;# Link Qt libraries&#10;target_link_libraries(${PROJECT_NAME} PRIVATE&#10;    Qt6::Core&#10;    Qt6::Widgets&#10;)&#10;&#10;# Set target properties&#10;set_target_properties(${PROJECT_NAME} PROPERTIES&#10;    AUTOMOC ON&#10;    AUTORCC ON&#10;    AUTOUIC ON&#10;    OUTPUT_NAME &quot;PomodoroTimer&quot;&#10;)&#10;&#10;# Platform-specific configurations&#10;if(WIN32)&#10;    set_target_properties(${PROJECT_NAME} PROPERTIES&#10;        WIN32_EXECUTABLE TRUE&#10;    )&#10;elseif(APPLE)&#10;    set_target_properties(${PROJECT_NAME} PROPERTIES&#10;        MACOSX_BUNDLE TRUE&#10;        MACOSX_BUNDLE_BUNDLE_NAME &quot;Pomodoro Timer&quot;&#10;        MACOSX_BUNDLE_GUI_IDENTIFIER &quot;com.pomodoroapp.timer&quot;&#10;        MACOSX_BUNDLE_BUNDLE_VERSION &quot;${PROJECT_VERSION}&quot;&#10;        MACOSX_BUNDLE_SHORT_VERSION_STRING &quot;${PROJECT_VERSION}&quot;&#10;        MACOSX_BUNDLE_INFO_STRING &quot;Pomodoro Focus Timer&quot;&#10;    )&#10;endif()&#10;&#10;# Compiler warnings and optimizations&#10;if(MSVC)&#10;    target_compile_options(${PROJECT_NAME} PRIVATE&#10;        /W4 /WX-&#10;        $&lt;$&lt;CONFIG:Release&gt;:/O2&gt;&#10;    )&#10;else()&#10;    target_compile_options(${PROJECT_NAME} PRIVATE&#10;        -Wall -Wextra -Wpedantic&#10;        $&lt;$&lt;CONFIG:Release&gt;:-O3&gt;&#10;        $&lt;$&lt;CONFIG:Debug&gt;:-g -O0&gt;&#10;    )&#10;endif()&#10;&#10;# --- Installation Rules ---&#10;&#10;# Configure desktop file for Linux&#10;if(UNIX AND NOT APPLE)&#10;    configure_file(&#10;        &quot;${CMAKE_CURRENT_SOURCE_DIR}/pomodoro-timer.desktop.in&quot;&#10;        &quot;${CMAKE_CURRENT_BINARY_DIR}/pomodoro-timer.desktop&quot;&#10;        @ONLY&#10;    )&#10;&#10;    install(&#10;        FILES &quot;${CMAKE_CURRENT_BINARY_DIR}/pomodoro-timer.desktop&quot;&#10;        DESTINATION &quot;${CMAKE_INSTALL_PREFIX}/share/applications&quot;&#10;    )&#10;endif()&#10;&#10;&#10;# Install rules (optional)&#10;if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)&#10;    set(CMAKE_INSTALL_PREFIX &quot;${CMAKE_BINARY_DIR}/install&quot; CACHE PATH &quot;Install prefix&quot; FORCE)&#10;endif()&#10;&#10;install(TARGETS ${PROJECT_NAME}&#10;    BUNDLE DESTINATION .&#10;    RUNTIME DESTINATION bin&#10;)&#10;" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.20)&#10;project(PomodoroTimer VERSION 0.1.1 LANGUAGES CXX)&#10;&#10;# Set C++ standard&#10;set(CMAKE_CXX_STANDARD 17)&#10;set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;set(CMAKE_CXX_EXTENSIONS OFF)&#10;&#10;# Find Qt6&#10;find_package(Qt6 REQUIRED COMPONENTS Core Widgets)&#10;qt6_standard_project_setup()&#10;&#10;# Include directories&#10;include_directories(src/core)&#10;include_directories(src/ui)&#10;include_directories(src/system)&#10;include_directories(src/utils)&#10;&#10;# Define source files with new structure&#10;set(CORE_HEADERS&#10;    src/core/TimerState.h&#10;    src/core/TimerController.h&#10;    src/core/PomodoroConfig.h&#10;)&#10;&#10;set(UI_HEADERS&#10;    src/ui/PomodoroTimer.h&#10;    src/ui/CircularProgressBar.h&#10;    src/ui/SettingsDialog.h&#10;    src/ui/StatisticsDialog.h&#10;)&#10;&#10;set(SYSTEM_HEADERS&#10;    src/system/SystemTrayManager.h&#10;    src/system/KeyboardShortcuts.h&#10;    src/system/NotificationManager.h&#10;)&#10;&#10;set(CORE_SOURCES&#10;    src/core/TimerState.cpp&#10;    src/core/TimerController.cpp&#10;    src/core/PomodoroConfig.cpp&#10;)&#10;&#10;set(UI_SOURCES&#10;    src/ui/PomodoroTimer.cpp&#10;    src/ui/CircularProgressBar.cpp&#10;    src/ui/SettingsDialog.cpp&#10;    src/ui/StatisticsDialog.cpp&#10;)&#10;&#10;set(SYSTEM_SOURCES&#10;    src/system/SystemTrayManager.cpp&#10;    src/system/KeyboardShortcuts.cpp&#10;    src/system/NotificationManager.cpp&#10;)&#10;&#10;set(ALL_HEADERS ${CORE_HEADERS} ${UI_HEADERS} ${SYSTEM_HEADERS})&#10;set(ALL_SOURCES main.cpp ${CORE_SOURCES} ${UI_SOURCES} ${SYSTEM_SOURCES})&#10;&#10;# Create executable&#10;qt6_add_executable(${PROJECT_NAME} ${ALL_SOURCES} ${ALL_HEADERS})&#10;&#10;# Link Qt libraries&#10;target_link_libraries(${PROJECT_NAME} PRIVATE&#10;    Qt6::Core&#10;    Qt6::Widgets&#10;)&#10;&#10;# Set target properties&#10;set_target_properties(${PROJECT_NAME} PROPERTIES&#10;    AUTOMOC ON&#10;    AUTORCC ON&#10;    AUTOUIC ON&#10;    OUTPUT_NAME &quot;PomodoroTimer&quot;&#10;)&#10;&#10;# Platform-specific configurations&#10;if(WIN32)&#10;    set_target_properties(${PROJECT_NAME} PROPERTIES&#10;        WIN32_EXECUTABLE TRUE&#10;    )&#10;elseif(APPLE)&#10;    set_target_properties(${PROJECT_NAME} PROPERTIES&#10;        MACOSX_BUNDLE TRUE&#10;        MACOSX_BUNDLE_BUNDLE_NAME &quot;Pomodoro Timer&quot;&#10;        MACOSX_BUNDLE_GUI_IDENTIFIER &quot;com.pomodoroapp.timer&quot;&#10;        MACOSX_BUNDLE_BUNDLE_VERSION &quot;${PROJECT_VERSION}&quot;&#10;        MACOSX_BUNDLE_SHORT_VERSION_STRING &quot;${PROJECT_VERSION}&quot;&#10;        MACOSX_BUNDLE_INFO_STRING &quot;Pomodoro Focus Timer&quot;&#10;    )&#10;endif()&#10;&#10;# Compiler warnings and optimizations&#10;if(MSVC)&#10;    target_compile_options(${PROJECT_NAME} PRIVATE&#10;        /W4 /WX-&#10;        $&lt;$&lt;CONFIG:Release&gt;:/O2&gt;&#10;    )&#10;else()&#10;    target_compile_options(${PROJECT_NAME} PRIVATE&#10;        -Wall -Wextra -Wpedantic&#10;        $&lt;$&lt;CONFIG:Release&gt;:-O3&gt;&#10;        $&lt;$&lt;CONFIG:Debug&gt;:-g -O0&gt;&#10;    )&#10;endif()&#10;&#10;# --- Installation Rules ---&#10;&#10;# Configure desktop file for Linux&#10;if(UNIX AND NOT APPLE)&#10;    configure_file(&#10;        &quot;${CMAKE_CURRENT_SOURCE_DIR}/resources/pomodoro-timer.desktop.in&quot;&#10;        &quot;${CMAKE_CURRENT_BINARY_DIR}/pomodoro-timer.desktop&quot;&#10;        @ONLY&#10;    )&#10;&#10;    install(&#10;        FILES &quot;${CMAKE_CURRENT_BINARY_DIR}/pomodoro-timer.desktop&quot;&#10;        DESTINATION &quot;${CMAKE_INSTALL_PREFIX}/share/applications&quot;&#10;    )&#10;endif()&#10;&#10;&#10;# Install rules (optional)&#10;if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)&#10;    set(CMAKE_INSTALL_PREFIX &quot;${CMAKE_BINARY_DIR}/install&quot; CACHE PATH &quot;Install prefix&quot; FORCE)&#10;endif()&#10;&#10;install(TARGETS ${PROJECT_NAME}&#10;    BUNDLE DESTINATION .&#10;    RUNTIME DESTINATION bin&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/PROJECT_STRUCTURE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/PROJECT_STRUCTURE.md" />
              <option name="updatedContent" value="# Pomodoro Timer - Структура проекта&#10;&#10;## Обзор&#10;Этот документ описывает организацию файловой системы проекта Pomodoro Timer для обеспечения лучшей читаемости, сопровождения и масштабируемости кода.&#10;&#10;## Структура папок&#10;&#10;### `/src/` - Исходный код&#10;Основная папка с исходным кодом, организованная по функциональным модулям:&#10;&#10;#### `/src/core/` - Основная логика&#10;Содержит базовую бизнес-логику приложения:&#10;- `TimerState.h/cpp` - Перечисления и утилиты для состояний таймера&#10;- `TimerController.h/cpp` - Контроллер управления таймером (если есть)&#10;- `PomodoroConfig.h/cpp` - Конфигурация и настройки приложения&#10;&#10;#### `/src/ui/` - Пользовательский интерфейс&#10;Все компоненты графического интерфейса:&#10;- `PomodoroTimer.h/cpp` - Главное окно приложения&#10;- `CircularProgressBar.h/cpp` - Кастомный виджет круглого прогресс-бара&#10;- `SettingsDialog.h/cpp` - Диалог настроек&#10;- `StatisticsDialog.h/cpp` - Диалог статистики&#10;&#10;#### `/src/system/` - Системная интеграция&#10;Компоненты для взаимодействия с операционной системой:&#10;- `SystemTrayManager.h/cpp` - Управление системным треем&#10;- `KeyboardShortcuts.h/cpp` - Глобальные горячие клавиши&#10;- `NotificationManager.h/cpp` - Системные уведомления&#10;&#10;#### `/src/utils/` - Утилиты&#10;Вспомогательные классы и функции (пока пуста, готова для будущих утилит)&#10;&#10;### `/resources/` - Ресурсы&#10;Статические ресурсы приложения:&#10;- `logoTimer.png` - Иконка приложения&#10;- `pomodoro-timer.desktop.in` - Шаблон desktop-файла для Linux&#10;&#10;### `/docs/` - Документация&#10;Документация проекта:&#10;- `PROJECT_STRUCTURE.md` - Этот файл&#10;- (планируется: руководства пользователя, API документации)&#10;&#10;### `/tests/` - Тесты&#10;Модульные и интеграционные тесты (готова для будущих тестов)&#10;&#10;## Принципы организации&#10;&#10;### 1. Разделение ответственности&#10;- **Core**: Бизнес-логика, не зависящая от UI&#10;- **UI**: Только код интерфейса и взаимодействия с пользователем&#10;- **System**: Специфичные для ОС функции&#10;- **Utils**: Переиспользуемые утилиты&#10;&#10;### 2. Минимальные зависимости&#10;- Core модули не зависят от UI&#10;- UI модули могут использовать Core&#10;- System модули изолированы и используются через интерфейсы&#10;&#10;### 3. Масштабируемость&#10;Структура позволяет легко добавлять новые компоненты без нарушения существующей архитектуры.&#10;&#10;## Сборка проекта&#10;&#10;Обновленный `CMakeLists.txt` автоматически находит все файлы в правильных папках и настраивает include пути.&#10;&#10;```bash&#10;mkdir build &amp;&amp; cd build&#10;cmake ..&#10;make&#10;```&#10;&#10;## Include директивы&#10;&#10;Благодаря настроенным include путям в CMake, файлы могут включать друг друга следующим образом:&#10;&#10;```cpp&#10;// Из UI модулей&#10;#include &quot;core/TimerState.h&quot;&#10;#include &quot;system/SystemTrayManager.h&quot;&#10;&#10;// Из Core модулей  &#10;#include &quot;TimerState.h&quot;  // внутри того же модуля&#10;&#10;// Из System модулей&#10;#include &quot;core/TimerState.h&quot;&#10;```&#10;&#10;## Будущие улучшения&#10;&#10;1. **Модульность**: Превратить компоненты в отдельные библиотеки&#10;2. **Тестирование**: Добавить unit тесты в папку `/tests/`&#10;3. **Плагины**: Создать систему плагинов в `/src/plugins/`&#10;4. **Локализация**: Добавить файлы переводов в `/resources/translations/`&#10;5. **Конфигурация**: Вынести конфиги в `/config/`" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.cpp" />
              <option name="originalContent" value="#include &lt;QApplication&gt;&#10;#include &lt;QScreen&gt;&#10;#include &lt;QPainter&gt;&#10;#include &lt;QPixmap&gt;&#10;#include &lt;QRadialGradient&gt;&#10;#include &lt;QPen&gt;&#10;#include &quot;ui/PomodoroTimer.h&quot;&#10;&#10;namespace {&#10;    // Application constants - use QStringLiteral for compile-time optimization&#10;    const QString APP_NAME = QStringLiteral(&quot;Pomodoro Timer&quot;);&#10;    const QString APP_VERSION = QStringLiteral(&quot;0.1.1&quot;);&#10;    const QString ORGANIZATION = QStringLiteral(&quot;PomodoroApp&quot;);&#10;&#10;    // Icon generation constants&#10;    constexpr double TOMATO_SIZE_RATIO = 0.8;&#10;    constexpr double STEM_SIZE_RATIO = 0.15;&#10;    constexpr double TOMATO_FLATTEN_RATIO = 0.9;&#10;    constexpr int PEN_WIDTH = 1;&#10;    constexpr int HIGHLIGHT_ALPHA = 100;&#10;&#10;    // Forward declaration for createTomatoIcon&#10;    QIcon createTomatoIcon(int size = 32);&#10;&#10;    // Use thread-safe singleton pattern instead of global variable&#10;    class IconCache {&#10;    public:&#10;        static IconCache&amp; instance() {&#10;            static IconCache cache;&#10;            return cache;&#10;        }&#10;&#10;        const QIcon&amp; getApplicationIcon() {&#10;            if (m_cachedAppIcon.isNull()) {&#10;                initializeIcon();&#10;            }&#10;            return m_cachedAppIcon;&#10;        }&#10;&#10;    private:&#10;        QIcon m_cachedAppIcon;&#10;&#10;        void initializeIcon() {&#10;            constexpr int iconSizes[] = {16, 24, 32, 48, 64};&#10;            for (int size : iconSizes) {&#10;                m_cachedAppIcon.addPixmap(createTomatoIcon(size).pixmap(size, size));&#10;            }&#10;        }&#10;    };&#10;&#10;    QIcon createTomatoIcon(int size)&#10;    {&#10;        QPixmap pixmap(size, size);&#10;        pixmap.fill(Qt::transparent);&#10;&#10;        QPainter painter(&amp;pixmap);&#10;        painter.setRenderHint(QPainter::Antialiasing);&#10;&#10;        // Calculate proportions&#10;        const int tomatoSize = static_cast&lt;int&gt;(size * TOMATO_SIZE_RATIO);&#10;        const int stemSize = static_cast&lt;int&gt;(size * STEM_SIZE_RATIO);&#10;        const int margin = (size - tomatoSize) / 2;&#10;&#10;        // Draw tomato body with gradient&#10;        QRadialGradient tomatoGradient(size/2, size/2 + stemSize, tomatoSize/2);&#10;        tomatoGradient.setColorAt(0.0, QColor(255, 100, 100));&#10;        tomatoGradient.setColorAt(0.7, QColor(220, 50, 50));&#10;        tomatoGradient.setColorAt(1.0, QColor(180, 30, 30));&#10;&#10;        painter.setBrush(QBrush(tomatoGradient));&#10;        painter.setPen(QPen(QColor(150, 20, 20), PEN_WIDTH));&#10;&#10;        const QRect tomatoRect(margin, margin + stemSize, tomatoSize,&#10;                              static_cast&lt;int&gt;(tomatoSize * TOMATO_FLATTEN_RATIO));&#10;        painter.drawEllipse(tomatoRect);&#10;&#10;        // Draw stem and leaves&#10;        painter.setBrush(QBrush(QColor(34, 139, 34)));&#10;        painter.setPen(QPen(QColor(20, 100, 20), PEN_WIDTH));&#10;&#10;        // Main stem&#10;        const QRect stemRect(size/2 - stemSize/3, margin, stemSize/1.5, stemSize);&#10;        painter.drawRect(stemRect);&#10;&#10;        // Draw leaves using polygons - optimize polygon creation&#10;        QPolygon leftLeaf, rightLeaf;&#10;        leftLeaf.reserve(3);&#10;        rightLeaf.reserve(3);&#10;&#10;        leftLeaf &lt;&lt; QPoint(size/2 - stemSize/2, margin + stemSize/3)&#10;                 &lt;&lt; QPoint(size/2 - stemSize, margin)&#10;                 &lt;&lt; QPoint(size/2 - stemSize/3, margin + stemSize/2);&#10;&#10;        rightLeaf &lt;&lt; QPoint(size/2 + stemSize/2, margin + stemSize/3)&#10;                  &lt;&lt; QPoint(size/2 + stemSize, margin)&#10;                  &lt;&lt; QPoint(size/2 + stemSize/3, margin + stemSize/2);&#10;&#10;        painter.drawPolygon(leftLeaf);&#10;        painter.drawPolygon(rightLeaf);&#10;&#10;        // Add 3D highlight effect&#10;        painter.setBrush(QBrush(QColor(255, 150, 150, HIGHLIGHT_ALPHA)));&#10;        painter.setPen(Qt::NoPen);&#10;        const QRect highlightRect(margin + tomatoSize/4, margin + stemSize + tomatoSize/4,&#10;                                 tomatoSize/3, tomatoSize/4);&#10;        painter.drawEllipse(highlightRect);&#10;&#10;        return QIcon(pixmap);&#10;    }&#10;&#10;    void centerWindow(QWidget* window)&#10;    {&#10;        if (!window) {&#10;            qWarning() &lt;&lt; &quot;centerWindow: null window pointer&quot;;&#10;            return;&#10;        }&#10;&#10;        const QScreen* screen = QApplication::primaryScreen();&#10;        if (!screen) {&#10;            qWarning() &lt;&lt; &quot;centerWindow: no primary screen available&quot;;&#10;            return;&#10;        }&#10;&#10;        const QRect screenGeometry = screen-&gt;availableGeometry();&#10;        const int x = (screenGeometry.width() - window-&gt;width()) / 2;&#10;        const int y = (screenGeometry.height() - window-&gt;height()) / 2;&#10;        window-&gt;move(x, y);&#10;    }&#10;&#10;    void setupApplicationProperties(QApplication&amp; app)&#10;    {&#10;        app.setApplicationName(APP_NAME);&#10;        app.setApplicationVersion(APP_VERSION);&#10;        app.setOrganizationName(ORGANIZATION);&#10;        app.setWindowIcon(IconCache::instance().getApplicationIcon());&#10;        app.setQuitOnLastWindowClosed(false);&#10;    }&#10;}&#10;&#10;int main(int argc, char *argv[])&#10;{&#10;    QApplication app(argc, argv);&#10;&#10;    setupApplicationProperties(app);&#10;&#10;    PomodoroTimer timer;&#10;    timer.show();&#10;    centerWindow(&amp;timer);&#10;&#10;    return app.exec();&#10;}" />
              <option name="updatedContent" value="#include &lt;QApplication&gt;&#10;#include &lt;QScreen&gt;&#10;#include &lt;QPainter&gt;&#10;#include &lt;QPixmap&gt;&#10;#include &lt;QRadialGradient&gt;&#10;#include &lt;QPen&gt;&#10;#include &quot;PomodoroTimer.h&quot;&#10;&#10;namespace {&#10;    // Application constants - use QStringLiteral for compile-time optimization&#10;    const QString APP_NAME = QStringLiteral(&quot;Pomodoro Timer&quot;);&#10;    const QString APP_VERSION = QStringLiteral(&quot;0.1.1&quot;);&#10;    const QString ORGANIZATION = QStringLiteral(&quot;PomodoroApp&quot;);&#10;&#10;    // Icon generation constants&#10;    constexpr double TOMATO_SIZE_RATIO = 0.8;&#10;    constexpr double STEM_SIZE_RATIO = 0.15;&#10;    constexpr double TOMATO_FLATTEN_RATIO = 0.9;&#10;    constexpr int PEN_WIDTH = 1;&#10;    constexpr int HIGHLIGHT_ALPHA = 100;&#10;&#10;    // Forward declaration for createTomatoIcon&#10;    QIcon createTomatoIcon(int size = 32);&#10;&#10;    // Use thread-safe singleton pattern instead of global variable&#10;    class IconCache {&#10;    public:&#10;        static IconCache&amp; instance() {&#10;            static IconCache cache;&#10;            return cache;&#10;        }&#10;&#10;        const QIcon&amp; getApplicationIcon() {&#10;            if (m_cachedAppIcon.isNull()) {&#10;                initializeIcon();&#10;            }&#10;            return m_cachedAppIcon;&#10;        }&#10;&#10;    private:&#10;        QIcon m_cachedAppIcon;&#10;&#10;        void initializeIcon() {&#10;            constexpr int iconSizes[] = {16, 24, 32, 48, 64};&#10;            for (int size : iconSizes) {&#10;                m_cachedAppIcon.addPixmap(createTomatoIcon(size).pixmap(size, size));&#10;            }&#10;        }&#10;    };&#10;&#10;    QIcon createTomatoIcon(int size)&#10;    {&#10;        QPixmap pixmap(size, size);&#10;        pixmap.fill(Qt::transparent);&#10;&#10;        QPainter painter(&amp;pixmap);&#10;        painter.setRenderHint(QPainter::Antialiasing);&#10;&#10;        // Calculate proportions&#10;        const int tomatoSize = static_cast&lt;int&gt;(size * TOMATO_SIZE_RATIO);&#10;        const int stemSize = static_cast&lt;int&gt;(size * STEM_SIZE_RATIO);&#10;        const int margin = (size - tomatoSize) / 2;&#10;&#10;        // Draw tomato body with gradient&#10;        QRadialGradient tomatoGradient(size/2, size/2 + stemSize, tomatoSize/2);&#10;        tomatoGradient.setColorAt(0.0, QColor(255, 100, 100));&#10;        tomatoGradient.setColorAt(0.7, QColor(220, 50, 50));&#10;        tomatoGradient.setColorAt(1.0, QColor(180, 30, 30));&#10;&#10;        painter.setBrush(QBrush(tomatoGradient));&#10;        painter.setPen(QPen(QColor(150, 20, 20), PEN_WIDTH));&#10;&#10;        const QRect tomatoRect(margin, margin + stemSize, tomatoSize,&#10;                              static_cast&lt;int&gt;(tomatoSize * TOMATO_FLATTEN_RATIO));&#10;        painter.drawEllipse(tomatoRect);&#10;&#10;        // Draw stem and leaves&#10;        painter.setBrush(QBrush(QColor(34, 139, 34)));&#10;        painter.setPen(QPen(QColor(20, 100, 20), PEN_WIDTH));&#10;&#10;        // Main stem&#10;        const QRect stemRect(size/2 - stemSize/3, margin, stemSize/1.5, stemSize);&#10;        painter.drawRect(stemRect);&#10;&#10;        // Draw leaves using polygons - optimize polygon creation&#10;        QPolygon leftLeaf, rightLeaf;&#10;        leftLeaf.reserve(3);&#10;        rightLeaf.reserve(3);&#10;&#10;        leftLeaf &lt;&lt; QPoint(size/2 - stemSize/2, margin + stemSize/3)&#10;                 &lt;&lt; QPoint(size/2 - stemSize, margin)&#10;                 &lt;&lt; QPoint(size/2 - stemSize/3, margin + stemSize/2);&#10;&#10;        rightLeaf &lt;&lt; QPoint(size/2 + stemSize/2, margin + stemSize/3)&#10;                  &lt;&lt; QPoint(size/2 + stemSize, margin)&#10;                  &lt;&lt; QPoint(size/2 + stemSize/3, margin + stemSize/2);&#10;&#10;        painter.drawPolygon(leftLeaf);&#10;        painter.drawPolygon(rightLeaf);&#10;&#10;        // Add 3D highlight effect&#10;        painter.setBrush(QBrush(QColor(255, 150, 150, HIGHLIGHT_ALPHA)));&#10;        painter.setPen(Qt::NoPen);&#10;        const QRect highlightRect(margin + tomatoSize/4, margin + stemSize + tomatoSize/4,&#10;                                 tomatoSize/3, tomatoSize/4);&#10;        painter.drawEllipse(highlightRect);&#10;&#10;        return QIcon(pixmap);&#10;    }&#10;&#10;    void centerWindow(QWidget* window)&#10;    {&#10;        if (!window) {&#10;            qWarning() &lt;&lt; &quot;centerWindow: null window pointer&quot;;&#10;            return;&#10;        }&#10;&#10;        const QScreen* screen = QApplication::primaryScreen();&#10;        if (!screen) {&#10;            qWarning() &lt;&lt; &quot;centerWindow: no primary screen available&quot;;&#10;            return;&#10;        }&#10;&#10;        const QRect screenGeometry = screen-&gt;availableGeometry();&#10;        const int x = (screenGeometry.width() - window-&gt;width()) / 2;&#10;        const int y = (screenGeometry.height() - window-&gt;height()) / 2;&#10;        window-&gt;move(x, y);&#10;    }&#10;&#10;    void setupApplicationProperties(QApplication&amp; app)&#10;    {&#10;        app.setApplicationName(APP_NAME);&#10;        app.setApplicationVersion(APP_VERSION);&#10;        app.setOrganizationName(ORGANIZATION);&#10;        app.setWindowIcon(IconCache::instance().getApplicationIcon());&#10;        app.setQuitOnLastWindowClosed(false);&#10;    }&#10;}&#10;&#10;int main(int argc, char *argv[])&#10;{&#10;    QApplication app(argc, argv);&#10;&#10;    setupApplicationProperties(app);&#10;&#10;    PomodoroTimer timer;&#10;    timer.show();&#10;    centerWindow(&amp;timer);&#10;&#10;    return app.exec();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/TimerController.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/TimerController.cpp" />
              <option name="originalContent" value="#include &quot;TimerController.h&quot;&#10;#include &lt;QDebug&gt;&#10;&#10;TimerController::TimerController(QObject *parent)&#10;    : QObject(parent)&#10;    , m_timer(std::make_unique&lt;QTimer&gt;(this))&#10;{&#10;    connect(m_timer.get(), &amp;QTimer::timeout, this, &amp;TimerController::onTimerTick);&#10;    m_timer-&gt;setInterval(1000); // 1 second&#10;    reset();&#10;}&#10;&#10;void TimerController::start()&#10;{&#10;    if (m_state == TimerState::Stopped) {&#10;        updateTotalSeconds();&#10;        m_remainingSeconds = m_totalSeconds;&#10;    }&#10;&#10;    m_state = TimerState::Running;&#10;    m_timer-&gt;start();&#10;    emit stateChanged(m_state);&#10;}&#10;&#10;void TimerController::pause()&#10;{&#10;    if (m_state == TimerState::Running) {&#10;        m_state = TimerState::Paused;&#10;        m_timer-&gt;stop();&#10;        emit stateChanged(m_state);&#10;    }&#10;}&#10;&#10;void TimerController::reset()&#10;{&#10;    m_timer-&gt;stop();&#10;    m_state = TimerState::Stopped;&#10;    m_currentSessionType = SessionType::Work;&#10;    updateTotalSeconds();&#10;    m_remainingSeconds = m_totalSeconds;&#10;&#10;    emit stateChanged(m_state);&#10;    emit sessionChanged(m_currentSessionType);&#10;    emit timeChanged(m_remainingSeconds);&#10;}&#10;&#10;void TimerController::skip()&#10;{&#10;    m_timer-&gt;stop();&#10;    startNextSession();&#10;}&#10;&#10;double TimerController::progressPercentage() const&#10;{&#10;    if (m_totalSeconds == 0) return 0.0;&#10;    return (static_cast&lt;double&gt;(m_totalSeconds - m_remainingSeconds) / m_totalSeconds) * 100.0;&#10;}&#10;&#10;void TimerController::onTimerTick()&#10;{&#10;    if (m_remainingSeconds &gt; 0) {&#10;        --m_remainingSeconds;&#10;        emit timeChanged(m_remainingSeconds);&#10;    } else {&#10;        m_timer-&gt;stop();&#10;        emit timerFinished();&#10;        startNextSession();&#10;    }&#10;}&#10;&#10;void TimerController::startNextSession()&#10;{&#10;    switch (m_currentSessionType) {&#10;        case SessionType::Work:&#10;            ++m_completedSessions;&#10;            if (m_completedSessions % SESSIONS_BEFORE_LONG_BREAK == 0) {&#10;                m_currentSessionType = SessionType::LongBreak;&#10;            } else {&#10;                m_currentSessionType = SessionType::ShortBreak;&#10;            }&#10;            break;&#10;&#10;        case SessionType::ShortBreak:&#10;        case SessionType::LongBreak:&#10;            m_currentSessionType = SessionType::Work;&#10;            break;&#10;    }&#10;&#10;    m_state = TimerState::Stopped;&#10;    updateTotalSeconds();&#10;    m_remainingSeconds = m_totalSeconds;&#10;&#10;    emit sessionChanged(m_currentSessionType);&#10;    emit stateChanged(m_state);&#10;    emit timeChanged(m_remainingSeconds);&#10;}&#10;&#10;void TimerController::updateTotalSeconds()&#10;{&#10;    switch (m_currentSessionType) {&#10;        case SessionType::Work:&#10;            m_totalSeconds = m_workDuration;&#10;            break;&#10;        case SessionType::ShortBreak:&#10;            m_totalSeconds = m_shortBreakDuration;&#10;            break;&#10;        case SessionType::LongBreak:&#10;            m_totalSeconds = m_longBreakDuration;&#10;            break;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;TimerController.h&quot;&#10;#include &lt;QDebug&gt;&#10;&#10;TimerController::TimerController(QObject *parent)&#10;    : QObject(parent)&#10;    , m_timer(std::make_unique&lt;QTimer&gt;(this))&#10;{&#10;    connect(m_timer.get(), &amp;QTimer::timeout, this, &amp;TimerController::onTimerTick);&#10;    m_timer-&gt;setInterval(1000); // 1 second&#10;    reset();&#10;}&#10;&#10;void TimerController::start()&#10;{&#10;    if (m_state == TimerStatus::Stopped) {&#10;        updateTotalSeconds();&#10;        m_remainingSeconds = m_totalSeconds;&#10;    }&#10;&#10;    m_state = TimerStatus::Running;&#10;    m_timer-&gt;start();&#10;    emit stateChanged(m_state);&#10;}&#10;&#10;void TimerController::pause()&#10;{&#10;    if (m_state == TimerStatus::Running) {&#10;        m_state = TimerStatus::Paused;&#10;        m_timer-&gt;stop();&#10;        emit stateChanged(m_state);&#10;    }&#10;}&#10;&#10;void TimerController::reset()&#10;{&#10;    m_timer-&gt;stop();&#10;    m_state = TimerStatus::Stopped;&#10;    m_currentSessionType = SessionType::Work;&#10;    updateTotalSeconds();&#10;    m_remainingSeconds = m_totalSeconds;&#10;&#10;    emit stateChanged(m_state);&#10;    emit sessionChanged(m_currentSessionType);&#10;    emit timeChanged(m_remainingSeconds);&#10;}&#10;&#10;void TimerController::skip()&#10;{&#10;    m_timer-&gt;stop();&#10;    startNextSession();&#10;}&#10;&#10;double TimerController::progressPercentage() const&#10;{&#10;    if (m_totalSeconds == 0) return 0.0;&#10;    return (static_cast&lt;double&gt;(m_totalSeconds - m_remainingSeconds) / m_totalSeconds) * 100.0;&#10;}&#10;&#10;void TimerController::onTimerTick()&#10;{&#10;    if (m_remainingSeconds &gt; 0) {&#10;        --m_remainingSeconds;&#10;        emit timeChanged(m_remainingSeconds);&#10;    } else {&#10;        m_timer-&gt;stop();&#10;        emit timerFinished();&#10;        startNextSession();&#10;    }&#10;}&#10;&#10;void TimerController::startNextSession()&#10;{&#10;    switch (m_currentSessionType) {&#10;        case SessionType::Work:&#10;            ++m_completedSessions;&#10;            if (m_completedSessions % SESSIONS_BEFORE_LONG_BREAK == 0) {&#10;                m_currentSessionType = SessionType::LongBreak;&#10;            } else {&#10;                m_currentSessionType = SessionType::ShortBreak;&#10;            }&#10;            break;&#10;&#10;        case SessionType::ShortBreak:&#10;        case SessionType::LongBreak:&#10;            m_currentSessionType = SessionType::Work;&#10;            break;&#10;    }&#10;&#10;    m_state = TimerStatus::Stopped;&#10;    updateTotalSeconds();&#10;    m_remainingSeconds = m_totalSeconds;&#10;&#10;    emit sessionChanged(m_currentSessionType);&#10;    emit stateChanged(m_state);&#10;    emit timeChanged(m_remainingSeconds);&#10;}&#10;&#10;void TimerController::updateTotalSeconds()&#10;{&#10;    switch (m_currentSessionType) {&#10;        case SessionType::Work:&#10;            m_totalSeconds = m_workDuration;&#10;            break;&#10;        case SessionType::ShortBreak:&#10;            m_totalSeconds = m_shortBreakDuration;&#10;            break;&#10;        case SessionType::LongBreak:&#10;            m_totalSeconds = m_longBreakDuration;&#10;            break;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/core/TimerController.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/core/TimerController.h" />
              <option name="originalContent" value="#ifndef TIMERCONTROLLER_H&#10;#define TIMERCONTROLLER_H&#10;&#10;#include &lt;QObject&gt;&#10;#include &lt;QTimer&gt;&#10;#include &lt;QDateTime&gt;&#10;#include &lt;memory&gt;&#10;&#10;enum class SessionType {&#10;    Work,&#10;    ShortBreak,&#10;    LongBreak&#10;};&#10;&#10;enum class TimerState {&#10;    Stopped,&#10;    Running,&#10;    Paused&#10;};&#10;&#10;class TimerController : public QObject&#10;{&#10;    Q_OBJECT&#10;&#10;public:&#10;    explicit TimerController(QObject *parent = nullptr);&#10;    ~TimerController() override = default;&#10;&#10;    // Timer control&#10;    void start();&#10;    void pause();&#10;    void reset();&#10;    void skip();&#10;&#10;    // Getters&#10;    [[nodiscard]] int remainingSeconds() const { return m_remainingSeconds; }&#10;    [[nodiscard]] int totalSeconds() const { return m_totalSeconds; }&#10;    [[nodiscard]] SessionType currentSessionType() const { return m_currentSessionType; }&#10;    [[nodiscard]] TimerState state() const { return m_state; }&#10;    [[nodiscard]] int completedSessions() const { return m_completedSessions; }&#10;    [[nodiscard]] double progressPercentage() const;&#10;&#10;    // Configuration&#10;    void setWorkDuration(int seconds) { m_workDuration = seconds; }&#10;    void setShortBreakDuration(int seconds) { m_shortBreakDuration = seconds; }&#10;    void setLongBreakDuration(int seconds) { m_longBreakDuration = seconds; }&#10;&#10;signals:&#10;    void timeChanged(int remainingSeconds);&#10;    void sessionChanged(SessionType type);&#10;    void timerFinished();&#10;    void stateChanged(TimerState state);&#10;&#10;private slots:&#10;    void onTimerTick();&#10;&#10;private:&#10;    void startNextSession();&#10;    void updateTotalSeconds();&#10;&#10;    // Timer objects&#10;    std::unique_ptr&lt;QTimer&gt; m_timer;&#10;&#10;    // State&#10;    TimerState m_state = TimerState::Stopped;&#10;    SessionType m_currentSessionType = SessionType::Work;&#10;&#10;    // Time tracking&#10;    int m_remainingSeconds = 0;&#10;    int m_totalSeconds = 0;&#10;    int m_completedSessions = 0;&#10;&#10;    // Configuration&#10;    int m_workDuration = 1500;      // 25 minutes&#10;    int m_shortBreakDuration = 300; // 5 minutes&#10;    int m_longBreakDuration = 900;  // 15 minutes&#10;&#10;    static constexpr int SESSIONS_BEFORE_LONG_BREAK = 4;&#10;};&#10;&#10;#endif // TIMERCONTROLLER_H&#10;" />
              <option name="updatedContent" value="#ifndef TIMERCONTROLLER_H&#10;#define TIMERCONTROLLER_H&#10;&#10;#include &lt;QObject&gt;&#10;#include &lt;QTimer&gt;&#10;#include &lt;QDateTime&gt;&#10;#include &lt;memory&gt;&#10;&#10;enum class SessionType {&#10;    Work,&#10;    ShortBreak,&#10;    LongBreak&#10;};&#10;&#10;enum class TimerStatus {&#10;    Stopped,&#10;    Running,&#10;    Paused&#10;};&#10;&#10;class TimerController : public QObject&#10;{&#10;    Q_OBJECT&#10;&#10;public:&#10;    explicit TimerController(QObject *parent = nullptr);&#10;    ~TimerController() override = default;&#10;&#10;    // Timer control&#10;    void start();&#10;    void pause();&#10;    void reset();&#10;    void skip();&#10;&#10;    // Getters&#10;    [[nodiscard]] int remainingSeconds() const { return m_remainingSeconds; }&#10;    [[nodiscard]] int totalSeconds() const { return m_totalSeconds; }&#10;    [[nodiscard]] SessionType currentSessionType() const { return m_currentSessionType; }&#10;    [[nodiscard]] TimerStatus state() const { return m_state; }&#10;    [[nodiscard]] int completedSessions() const { return m_completedSessions; }&#10;    [[nodiscard]] double progressPercentage() const;&#10;&#10;    // Configuration&#10;    void setWorkDuration(int seconds) { m_workDuration = seconds; }&#10;    void setShortBreakDuration(int seconds) { m_shortBreakDuration = seconds; }&#10;    void setLongBreakDuration(int seconds) { m_longBreakDuration = seconds; }&#10;&#10;signals:&#10;    void timeChanged(int remainingSeconds);&#10;    void sessionChanged(SessionType type);&#10;    void timerFinished();&#10;    void stateChanged(TimerStatus state);&#10;&#10;private slots:&#10;    void onTimerTick();&#10;&#10;private:&#10;    void startNextSession();&#10;    void updateTotalSeconds();&#10;&#10;    // Timer objects&#10;    std::unique_ptr&lt;QTimer&gt; m_timer;&#10;&#10;    // State&#10;    TimerStatus m_state = TimerStatus::Stopped;&#10;    SessionType m_currentSessionType = SessionType::Work;&#10;&#10;    // Time tracking&#10;    int m_remainingSeconds = 0;&#10;    int m_totalSeconds = 0;&#10;    int m_completedSessions = 0;&#10;&#10;    // Configuration&#10;    int m_workDuration = 1500;      // 25 minutes&#10;    int m_shortBreakDuration = 300; // 5 minutes&#10;    int m_longBreakDuration = 900;  // 15 minutes&#10;&#10;    static constexpr int SESSIONS_BEFORE_LONG_BREAK = 4;&#10;};&#10;&#10;#endif // TIMERCONTROLLER_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/system/SystemTrayManager.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/system/SystemTrayManager.h" />
              <option name="originalContent" value="#ifndef SYSTEMTRAYMANAGER_H&#10;#define SYSTEMTRAYMANAGER_H&#10;&#10;#include &lt;QSystemTrayIcon&gt;&#10;#include &lt;QMenu&gt;&#10;#include &quot;core/TimerState.h&quot;&#10;&#10;class SystemTrayManager : public QObject&#10;{&#10;    Q_OBJECT&#10;&#10;public:&#10;    explicit SystemTrayManager(QObject *parent = nullptr);&#10;    ~SystemTrayManager() override;&#10;&#10;    void show();&#10;    void hide();&#10;    bool isVisible() const;&#10;    void updateTooltip(TimerState state, bool isRunning, const QString &amp;timeRemaining, int currentSession, int totalSessions);&#10;    void showMessage(const QString &amp;title, const QString &amp;message);&#10;&#10;signals:&#10;    void showMainWindow();&#10;    void startPauseRequested();&#10;    void resetRequested();&#10;    void skipRequested();&#10;    void settingsRequested();&#10;    void statisticsRequested();&#10;    void quitRequested();&#10;&#10;private slots:&#10;    void onTrayIconActivated(QSystemTrayIcon::ActivationReason reason);&#10;&#10;private:&#10;    void setupTrayMenu();&#10;&#10;    QSystemTrayIcon *m_trayIcon;&#10;    QMenu *m_trayMenu;&#10;&#10;    // Cache to avoid unnecessary tooltip updates&#10;    QString m_lastTooltip;&#10;};&#10;&#10;#endif // SYSTEMTRAYMANAGER_H&#10;" />
              <option name="updatedContent" value="#ifndef SYSTEMTRAYMANAGER_H&#10;#define SYSTEMTRAYMANAGER_H&#10;&#10;#include &lt;QSystemTrayIcon&gt;&#10;#include &lt;QMenu&gt;&#10;#include &quot;TimerState.h&quot;&#10;&#10;class SystemTrayManager : public QObject&#10;{&#10;    Q_OBJECT&#10;&#10;public:&#10;    explicit SystemTrayManager(QObject *parent = nullptr);&#10;    ~SystemTrayManager() override;&#10;&#10;    void show();&#10;    void hide();&#10;    bool isVisible() const;&#10;    void updateTooltip(TimerState state, bool isRunning, const QString &amp;timeRemaining, int currentSession, int totalSessions);&#10;    void showMessage(const QString &amp;title, const QString &amp;message);&#10;&#10;signals:&#10;    void showMainWindow();&#10;    void startPauseRequested();&#10;    void resetRequested();&#10;    void skipRequested();&#10;    void settingsRequested();&#10;    void statisticsRequested();&#10;    void quitRequested();&#10;&#10;private slots:&#10;    void onTrayIconActivated(QSystemTrayIcon::ActivationReason reason);&#10;&#10;private:&#10;    void setupTrayMenu();&#10;&#10;    QSystemTrayIcon *m_trayIcon;&#10;    QMenu *m_trayMenu;&#10;&#10;    // Cache to avoid unnecessary tooltip updates&#10;    QString m_lastTooltip;&#10;};&#10;&#10;#endif // SYSTEMTRAYMANAGER_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/ui/PomodoroTimer.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ui/PomodoroTimer.cpp" />
              <option name="originalContent" value="#include &quot;PomodoroTimer.h&quot;&#10;#include &quot;CircularProgressBar.h&quot;&#10;#include &quot;SettingsDialog.h&quot;&#10;#include &quot;StatisticsDialog.h&quot;&#10;#include &quot;system/SystemTrayManager.h&quot;&#10;#include &quot;system/KeyboardShortcuts.h&quot;&#10;#include &quot;system/NotificationManager.h&quot;&#10;#include &quot;core/TimerState.h&quot;&#10;&#10;#include &lt;QApplication&gt;&#10;#include &lt;QDateTime&gt;&#10;#include &lt;QFont&gt;&#10;#include &lt;QKeyEvent&gt;&#10;#include &lt;QSettings&gt;&#10;#include &lt;QVBoxLayout&gt;&#10;&#10;namespace {&#10;    // UI Layout constants&#10;    constexpr int WINDOW_WIDTH = 440;&#10;    constexpr int WINDOW_HEIGHT = 550;&#10;    constexpr int PROGRESS_BAR_SIZE = 220;&#10;    constexpr int MAIN_BUTTON_WIDTH = 100;&#10;    constexpr int MAIN_BUTTON_HEIGHT = 40;&#10;    constexpr int SMALL_BUTTON_WIDTH = 90;&#10;    constexpr int SMALL_BUTTON_HEIGHT = 35;&#10;    constexpr int LAYOUT_SPACING = 10;&#10;    constexpr int LAYOUT_MARGIN = 25;&#10;&#10;    // Font sizes&#10;    constexpr int TIME_FONT_SIZE = 24;&#10;    constexpr int STATUS_FONT_SIZE = 14;&#10;    constexpr int SESSION_FONT_SIZE = 12;&#10;    constexpr int BUTTON_FONT_SIZE = 11;&#10;&#10;    // Progress bar positioning&#10;    constexpr int TIME_LABEL_Y_OFFSET = 90;&#10;}&#10;&#10;PomodoroTimer::PomodoroTimer(QWidget *parent)&#10;    : QWidget(parent)&#10;    , m_timer(new QTimer(this))&#10;    , m_trayManager(std::make_unique&lt;SystemTrayManager&gt;(this))&#10;    , m_keyboardShortcuts(std::make_unique&lt;KeyboardShortcuts&gt;(this))&#10;    , m_notificationManager(std::make_unique&lt;NotificationManager&gt;(this))&#10;{&#10;    loadSettings();&#10;    setupUI();&#10;    setupConnections();&#10;    resetTimerState();&#10;    updateDisplay();&#10;&#10;    // Setup manager connections&#10;    m_notificationManager-&gt;setSystemTrayManager(m_trayManager.get());&#10;    m_notificationManager-&gt;setNotificationsEnabled(m_showNotifications);&#10;    m_trayManager-&gt;show();&#10;}&#10;&#10;PomodoroTimer::~PomodoroTimer()&#10;{&#10;    saveSettings();&#10;}&#10;&#10;void PomodoroTimer::setupUI()&#10;{&#10;    setFixedSize(WINDOW_WIDTH, WINDOW_HEIGHT);&#10;&#10;    m_mainFrame = new QFrame(this);&#10;    m_circularProgress = new CircularProgressBar(m_mainFrame);&#10;    m_circularProgress-&gt;setFixedSize(PROGRESS_BAR_SIZE, PROGRESS_BAR_SIZE);&#10;&#10;    createLabels();&#10;    createButtons();&#10;    createLayouts();&#10;    applyStyles();&#10;    updateButtonStates();&#10;}&#10;&#10;void PomodoroTimer::createLabels()&#10;{&#10;    // Time display label&#10;    m_timeLabel = new QLabel(&quot;25:00&quot;, m_circularProgress);&#10;    m_timeLabel-&gt;setAlignment(Qt::AlignCenter);&#10;    m_timeLabel-&gt;resize(PROGRESS_BAR_SIZE, 40);&#10;    m_timeLabel-&gt;move(0, TIME_LABEL_Y_OFFSET);&#10;&#10;    // Status indicator label&#10;    m_statusLabel = new QLabel(&quot;Ready to Focus&quot;, m_mainFrame);&#10;    m_statusLabel-&gt;setAlignment(Qt::AlignCenter);&#10;&#10;    // Session progress label&#10;    m_sessionLabel = new QLabel(&quot;Session 1 of 4&quot;, m_mainFrame);&#10;    m_sessionLabel-&gt;setAlignment(Qt::AlignCenter);&#10;}&#10;&#10;void PomodoroTimer::createButtons()&#10;{&#10;    m_startButton = new QPushButton(&quot;Start&quot;, m_mainFrame);&#10;    m_pauseButton = new QPushButton(&quot;Pause&quot;, m_mainFrame);&#10;    m_resetButton = new QPushButton(&quot;Reset&quot;, m_mainFrame);&#10;    m_settingsButton = new QPushButton(&quot;Settings&quot;, m_mainFrame);&#10;    m_skipButton = new QPushButton(&quot;Skip&quot;, m_mainFrame);&#10;    m_statsButton = new QPushButton(&quot;Statistics&quot;, m_mainFrame);&#10;&#10;    // Set button sizes&#10;    constexpr QSize mainButtonSize(MAIN_BUTTON_WIDTH, MAIN_BUTTON_HEIGHT);&#10;    constexpr QSize smallButtonSize(SMALL_BUTTON_WIDTH, SMALL_BUTTON_HEIGHT);&#10;&#10;    m_startButton-&gt;setFixedSize(mainButtonSize);&#10;    m_pauseButton-&gt;setFixedSize(mainButtonSize);&#10;    m_resetButton-&gt;setFixedSize(mainButtonSize);&#10;    m_settingsButton-&gt;setFixedSize(mainButtonSize);&#10;    m_skipButton-&gt;setFixedSize(smallButtonSize);&#10;    m_statsButton-&gt;setFixedSize(smallButtonSize);&#10;}&#10;&#10;void PomodoroTimer::createLayouts()&#10;{&#10;    // Progress bar layout&#10;    auto progressLayout = new QVBoxLayout();&#10;    progressLayout-&gt;addWidget(m_circularProgress, 0, Qt::AlignCenter);&#10;&#10;    // Main control buttons layout&#10;    auto buttonLayout = new QHBoxLayout();&#10;    buttonLayout-&gt;setSpacing(LAYOUT_SPACING);&#10;    buttonLayout-&gt;addWidget(m_startButton);&#10;    buttonLayout-&gt;addWidget(m_pauseButton);&#10;    buttonLayout-&gt;addWidget(m_resetButton);&#10;&#10;    // Header layout with settings button&#10;    auto headerLayout = new QHBoxLayout();&#10;    headerLayout-&gt;addStretch();&#10;    headerLayout-&gt;addWidget(m_settingsButton);&#10;&#10;    // Extra buttons layout&#10;    auto extraButtonLayout = new QHBoxLayout();&#10;    extraButtonLayout-&gt;setSpacing(LAYOUT_SPACING);&#10;    extraButtonLayout-&gt;addStretch();&#10;    extraButtonLayout-&gt;addWidget(m_skipButton);&#10;    extraButtonLayout-&gt;addWidget(m_statsButton);&#10;    extraButtonLayout-&gt;addStretch();&#10;&#10;    // Main layout assembly&#10;    auto mainLayout = new QVBoxLayout();&#10;    mainLayout-&gt;addLayout(headerLayout);&#10;    mainLayout-&gt;addSpacing(5);&#10;    mainLayout-&gt;addWidget(m_statusLabel);&#10;    mainLayout-&gt;addSpacing(15);&#10;    mainLayout-&gt;addLayout(progressLayout);&#10;    mainLayout-&gt;addSpacing(15);&#10;    mainLayout-&gt;addWidget(m_sessionLabel);&#10;    mainLayout-&gt;addSpacing(20);&#10;    mainLayout-&gt;addLayout(buttonLayout);&#10;    mainLayout-&gt;addSpacing(15);&#10;    mainLayout-&gt;addLayout(extraButtonLayout);&#10;    mainLayout-&gt;setContentsMargins(LAYOUT_MARGIN, LAYOUT_MARGIN, LAYOUT_MARGIN, LAYOUT_MARGIN);&#10;&#10;    m_mainFrame-&gt;setLayout(mainLayout);&#10;&#10;    // Frame layout&#10;    auto frameLayout = new QVBoxLayout();&#10;    frameLayout-&gt;addWidget(m_mainFrame);&#10;    frameLayout-&gt;setContentsMargins(0, 0, 0, 0);&#10;    setLayout(frameLayout);&#10;}&#10;&#10;void PomodoroTimer::applyStyles() const {&#10;    QFont timeFont = m_timeLabel-&gt;font();&#10;    timeFont.setPointSize(TIME_FONT_SIZE);&#10;    timeFont.setBold(true);&#10;    m_timeLabel-&gt;setFont(timeFont);&#10;&#10;    QFont statusFont = m_statusLabel-&gt;font();&#10;    statusFont.setPointSize(STATUS_FONT_SIZE);&#10;    m_statusLabel-&gt;setFont(statusFont);&#10;&#10;    QFont sessionFont = m_sessionLabel-&gt;font();&#10;    sessionFont.setPointSize(SESSION_FONT_SIZE);&#10;    m_sessionLabel-&gt;setFont(sessionFont);&#10;&#10;    QFont buttonFont;&#10;    buttonFont.setPointSize(BUTTON_FONT_SIZE);&#10;&#10;    const auto buttons = {m_startButton, m_pauseButton, m_resetButton,&#10;                         m_settingsButton, m_skipButton, m_statsButton};&#10;    for (auto* button : buttons) {&#10;        if (button) button-&gt;setFont(buttonFont);&#10;    }&#10;}&#10;&#10;void PomodoroTimer::setupConnections()&#10;{&#10;    // Timer connections&#10;    connect(m_timer, &amp;QTimer::timeout, this, &amp;PomodoroTimer::onUpdateTimer);&#10;&#10;    // Button connections&#10;    connect(m_startButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onStartTimer);&#10;    connect(m_pauseButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onPauseTimer);&#10;    connect(m_resetButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onResetTimer);&#10;    connect(m_settingsButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onShowSettings);&#10;    connect(m_skipButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onSkipSession);&#10;    connect(m_statsButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onShowStatistics);&#10;&#10;    // System tray connections&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::showMainWindow, this, &amp;PomodoroTimer::onToggleVisibility);&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::startPauseRequested, this, [this]() {&#10;        m_isRunning ? onPauseTimer() : onStartTimer();&#10;    });&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::resetRequested, this, &amp;PomodoroTimer::onResetTimer);&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::skipRequested, this, &amp;PomodoroTimer::onSkipSession);&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::settingsRequested, this, &amp;PomodoroTimer::onShowSettings);&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::statisticsRequested, this, &amp;PomodoroTimer::onShowStatistics);&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::quitRequested, qApp, &amp;QCoreApplication::quit);&#10;&#10;    // Keyboard shortcuts connections&#10;    connect(m_keyboardShortcuts.get(), &amp;KeyboardShortcuts::startPauseRequested, this, [this]() {&#10;        m_isRunning ? onPauseTimer() : onStartTimer();&#10;    });&#10;    connect(m_keyboardShortcuts.get(), &amp;KeyboardShortcuts::pauseRequested, this, &amp;PomodoroTimer::onPauseTimer);&#10;    connect(m_keyboardShortcuts.get(), &amp;KeyboardShortcuts::resetRequested, this, &amp;PomodoroTimer::onResetTimer);&#10;    connect(m_keyboardShortcuts.get(), &amp;KeyboardShortcuts::settingsRequested, this, &amp;PomodoroTimer::onShowSettings);&#10;    connect(m_keyboardShortcuts.get(), &amp;KeyboardShortcuts::skipRequested, this, &amp;PomodoroTimer::onSkipSession);&#10;}&#10;&#10;// Timer control methods&#10;void PomodoroTimer::onStartTimer()&#10;{&#10;    if (m_isRunning) return;&#10;&#10;    m_isRunning = true;&#10;    m_sessionStartTime = QDateTime::currentDateTime();&#10;    m_timer-&gt;start(TIMER_INTERVAL_MS);&#10;&#10;    m_statusLabel-&gt;setText(TimerStateHelper::getStatusMessage(m_currentState, true));&#10;    updateButtonStates();&#10;    updateDisplay();&#10;}&#10;&#10;void PomodoroTimer::onPauseTimer()&#10;{&#10;    if (!m_isRunning) return;&#10;&#10;    m_timer-&gt;stop();&#10;    m_isRunning = false;&#10;    m_statusLabel-&gt;setText(&quot;⏸ Paused&quot;);&#10;    updateButtonStates();&#10;    updateDisplay();&#10;}&#10;&#10;void PomodoroTimer::onResetTimer()&#10;{&#10;    m_timer-&gt;stop();&#10;    m_isRunning = false;&#10;    resetTimerState();&#10;    updateDisplay();&#10;    updateButtonStates();&#10;}&#10;&#10;void PomodoroTimer::onUpdateTimer()&#10;{&#10;    --m_currentTime;&#10;    updateDisplay();&#10;&#10;    if (m_currentTime &lt;= 0) {&#10;        onTimerFinished();&#10;    }&#10;}&#10;&#10;void PomodoroTimer::onTimerFinished()&#10;{&#10;    m_timer-&gt;stop();&#10;    m_isRunning = false;&#10;&#10;    // Update statistics&#10;    const QDateTime now = QDateTime::currentDateTime();&#10;    const int sessionDuration = static_cast&lt;int&gt;(m_sessionStartTime.secsTo(now));&#10;&#10;    if (m_currentState == TimerState::Work) {&#10;        m_totalWorkTime += sessionDuration;&#10;        m_totalSessions++;&#10;        m_completedSessions++;&#10;    } else {&#10;        m_totalBreakTime += sessionDuration;&#10;    }&#10;&#10;    // Determine next state and show notifications&#10;    QString message, nextAction;&#10;    if (m_currentState == TimerState::Work) {&#10;        message = &quot; Focus session completed!&quot;;&#10;&#10;        const bool isLongBreakTime = (m_completedSessions % SESSIONS_BEFORE_LONG_BREAK == 0);&#10;        updateTimerState(isLongBreakTime ? TimerState::LongBreak : TimerState::ShortBreak);&#10;        nextAction = isLongBreakTime ? &quot;Time for a long break! ‍♀️&quot; : &quot;Take a short break! ☕&quot;;&#10;    } else {&#10;        message = &quot;Break time finished!&quot;;&#10;        nextAction = &quot;Ready to focus again? &quot;;&#10;        updateTimerState(TimerState::Work);&#10;    }&#10;&#10;    m_notificationManager-&gt;showNotification(message + &quot; &quot; + nextAction);&#10;    onResetTimer();&#10;&#10;    // Auto-start if enabled&#10;    const bool shouldAutoStart = (m_currentState != TimerState::Work &amp;&amp; m_autoStartBreaks) ||&#10;                                (m_currentState == TimerState::Work &amp;&amp; m_autoStartWork);&#10;    if (shouldAutoStart) {&#10;        QTimer::singleShot(AUTO_START_DELAY_MS, this, &amp;PomodoroTimer::onStartTimer);&#10;    }&#10;&#10;    saveSettings();&#10;}&#10;&#10;// Helper methods&#10;void PomodoroTimer::resetTimerState()&#10;{&#10;    m_currentTime = TimerStateHelper::getDurationForState(m_currentState, m_workDuration, m_shortBreakDuration, m_longBreakDuration);&#10;    m_totalDuration = m_currentTime;&#10;    m_statusLabel-&gt;setText(TimerStateHelper::getStatusMessage(m_currentState, false));&#10;}&#10;&#10;void PomodoroTimer::updateTimerState(TimerState newState)&#10;{&#10;    m_currentState = newState;&#10;}&#10;&#10;QString PomodoroTimer::formatTime(int seconds) {&#10;  const int minutes = seconds / 60;&#10;  const int secs = seconds % 60;&#10;  return QString(&quot;%1:%2&quot;)&#10;      .arg(minutes, 2, 10, QChar('0'))&#10;      .arg(secs, 2, 10, QChar('0'));&#10;}&#10;void PomodoroTimer::needsDisplayUpdate() {}&#10;&#10;void PomodoroTimer::updateDisplay()&#10;{&#10;    m_timeLabel-&gt;setText(formatTime(m_currentTime));&#10;&#10;    const int progress = m_totalDuration &gt; 0 ?&#10;        ((m_totalDuration - m_currentTime) * 100) / m_totalDuration : 0;&#10;    m_circularProgress-&gt;setValue(progress);&#10;&#10;    updateSessionCounter();&#10;    updateWindowTitle();&#10;&#10;    // Update system tray&#10;    const int currentSession = (m_completedSessions % SESSIONS_BEFORE_LONG_BREAK) + 1;&#10;    m_trayManager-&gt;updateTooltip(m_currentState, m_isRunning, formatTime(m_currentTime),&#10;                                currentSession, SESSIONS_BEFORE_LONG_BREAK);&#10;}&#10;&#10;void PomodoroTimer::updateSessionCounter() const {&#10;    const int currentSession = (m_completedSessions % SESSIONS_BEFORE_LONG_BREAK) + 1;&#10;    m_sessionLabel-&gt;setText(QString(&quot;Session %1 of %2&quot;)&#10;                           .arg(currentSession)&#10;                           .arg(SESSIONS_BEFORE_LONG_BREAK));&#10;}&#10;&#10;void PomodoroTimer::updateButtonStates() const {&#10;    m_startButton-&gt;setEnabled(!m_isRunning);&#10;    m_pauseButton-&gt;setEnabled(m_isRunning);&#10;&#10;    const bool shouldShowReset = m_isRunning || m_currentTime &lt; m_totalDuration;&#10;    m_resetButton-&gt;setVisible(shouldShowReset);&#10;    m_resetButton-&gt;setEnabled(true);&#10;&#10;    m_skipButton-&gt;setEnabled(m_isRunning);&#10;    m_skipButton-&gt;setVisible(m_isRunning);&#10;&#10;    // Force layout update&#10;    if (m_mainFrame &amp;&amp; m_mainFrame-&gt;layout()) {&#10;        m_mainFrame-&gt;layout()-&gt;update();&#10;        m_mainFrame-&gt;updateGeometry();&#10;    }&#10;}&#10;&#10;void PomodoroTimer::updateWindowTitle() {&#10;  const QString timeRemaining = formatTime(m_currentTime);&#10;  const QString emoji = TimerStateHelper::getStateEmoji(m_currentState);&#10;&#10;  QString title;&#10;  if (m_isRunning) {&#10;    const QString stateText =&#10;        (m_currentState == TimerState::Work) ? &quot;Focus&quot; : &quot;Break&quot;;&#10;    title = QString(&quot;%1 %2: %3&quot;).arg(emoji, stateText, timeRemaining);&#10;  } else {&#10;    title = &quot; Pomodoro Timer&quot;;&#10;  }&#10;&#10;  setWindowTitle(title);&#10;}&#10;void PomodoroTimer::updateTrayTooltip() {}&#10;&#10;void PomodoroTimer::onShowSettings()&#10;{&#10;    SettingsDialog dialog(this);&#10;&#10;    dialog.setWorkDuration(m_workDuration / 60);&#10;    dialog.setShortBreakDuration(m_shortBreakDuration / 60);&#10;    dialog.setLongBreakDuration(m_longBreakDuration / 60);&#10;    dialog.setAutoStartBreaks(m_autoStartBreaks);&#10;    dialog.setAutoStartWork(m_autoStartWork);&#10;    dialog.setMinimizeToTray(m_minimizeToTray);&#10;    dialog.setShowNotifications(m_showNotifications);&#10;&#10;    if (dialog.exec() == QDialog::Accepted) {&#10;        m_workDuration = dialog.workDuration() * 60;&#10;        m_shortBreakDuration = dialog.shortBreakDuration() * 60;&#10;        m_longBreakDuration = dialog.longBreakDuration() * 60;&#10;        m_autoStartBreaks = dialog.autoStartBreaks();&#10;        m_autoStartWork = dialog.autoStartWork();&#10;        m_minimizeToTray = dialog.minimizeToTray();&#10;        m_showNotifications = dialog.showNotifications();&#10;&#10;        saveSettings();&#10;        onResetTimer();&#10;    }&#10;}&#10;&#10;void PomodoroTimer::onSkipSession()&#10;{&#10;    if (m_isRunning) {&#10;        onTimerFinished();&#10;    }&#10;}&#10;&#10;void PomodoroTimer::onShowStatistics()&#10;{&#10;    StatisticsDialog dialog(this);&#10;    dialog.setStatistics(m_totalSessions, m_totalWorkTime, m_totalBreakTime);&#10;    dialog.exec();&#10;}&#10;&#10;void PomodoroTimer::onToggleVisibility()&#10;{&#10;    if (isVisible()) {&#10;        hide();&#10;    } else {&#10;        show();&#10;        raise();&#10;        activateWindow();&#10;    }&#10;}&#10;&#10;void PomodoroTimer::loadSettings()&#10;{&#10;    QSettings settings;&#10;    m_workDuration = settings.value(&quot;workDuration&quot;, DEFAULT_WORK_DURATION).toInt();&#10;    m_shortBreakDuration = settings.value(&quot;shortBreakDuration&quot;, DEFAULT_SHORT_BREAK).toInt();&#10;    m_longBreakDuration = settings.value(&quot;longBreakDuration&quot;, DEFAULT_LONG_BREAK).toInt();&#10;    m_autoStartBreaks = settings.value(&quot;autoStartBreaks&quot;, false).toBool();&#10;    m_autoStartWork = settings.value(&quot;autoStartWork&quot;, false).toBool();&#10;    m_minimizeToTray = settings.value(&quot;minimizeToTray&quot;, true).toBool();&#10;    m_showNotifications = settings.value(&quot;showNotifications&quot;, true).toBool();&#10;    m_totalSessions = settings.value(&quot;totalSessions&quot;, 0).toInt();&#10;    m_totalWorkTime = settings.value(&quot;totalWorkTime&quot;, 0).toInt();&#10;    m_totalBreakTime = settings.value(&quot;totalBreakTime&quot;, 0).toInt();&#10;}&#10;&#10;void PomodoroTimer::saveSettings() const {&#10;    QSettings settings;&#10;    settings.setValue(&quot;workDuration&quot;, m_workDuration);&#10;    settings.setValue(&quot;shortBreakDuration&quot;, m_shortBreakDuration);&#10;    settings.setValue(&quot;longBreakDuration&quot;, m_longBreakDuration);&#10;    settings.setValue(&quot;autoStartBreaks&quot;, m_autoStartBreaks);&#10;    settings.setValue(&quot;autoStartWork&quot;, m_autoStartWork);&#10;    settings.setValue(&quot;minimizeToTray&quot;, m_minimizeToTray);&#10;    settings.setValue(&quot;showNotifications&quot;, m_showNotifications);&#10;    settings.setValue(&quot;totalSessions&quot;, m_totalSessions);&#10;    settings.setValue(&quot;totalWorkTime&quot;, m_totalWorkTime);&#10;    settings.setValue(&quot;totalBreakTime&quot;, m_totalBreakTime);&#10;}&#10;&#10;void PomodoroTimer::keyPressEvent(QKeyEvent *event)&#10;{&#10;    if (event-&gt;key() == Qt::Key_Escape) {&#10;        hide();&#10;    }&#10;    QWidget::keyPressEvent(event);&#10;}&#10;&#10;void PomodoroTimer::closeEvent(QCloseEvent *event)&#10;{&#10;    if (m_trayManager &amp;&amp; m_trayManager-&gt;isVisible()) {&#10;        hide();&#10;        event-&gt;ignore();&#10;&#10;        static bool firstHide = true;&#10;        if (firstHide) {&#10;            m_notificationManager-&gt;showNotification(&quot;Application was minimized to tray. Click the tray icon to show again.&quot;);&#10;            firstHide = false;&#10;        }&#10;    } else {&#10;        saveSettings();&#10;        event-&gt;accept();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;PomodoroTimer.h&quot;&#10;#include &quot;CircularProgressBar.h&quot;&#10;#include &quot;SettingsDialog.h&quot;&#10;#include &quot;StatisticsDialog.h&quot;&#10;#include &quot;SystemTrayManager.h&quot;&#10;#include &quot;KeyboardShortcuts.h&quot;&#10;#include &quot;NotificationManager.h&quot;&#10;#include &quot;TimerState.h&quot;&#10;&#10;#include &lt;QApplication&gt;&#10;#include &lt;QDateTime&gt;&#10;#include &lt;QFont&gt;&#10;#include &lt;QKeyEvent&gt;&#10;#include &lt;QSettings&gt;&#10;#include &lt;QVBoxLayout&gt;&#10;&#10;namespace {&#10;    // UI Layout constants&#10;    constexpr int WINDOW_WIDTH = 440;&#10;    constexpr int WINDOW_HEIGHT = 550;&#10;    constexpr int PROGRESS_BAR_SIZE = 220;&#10;    constexpr int MAIN_BUTTON_WIDTH = 100;&#10;    constexpr int MAIN_BUTTON_HEIGHT = 40;&#10;    constexpr int SMALL_BUTTON_WIDTH = 90;&#10;    constexpr int SMALL_BUTTON_HEIGHT = 35;&#10;    constexpr int LAYOUT_SPACING = 10;&#10;    constexpr int LAYOUT_MARGIN = 25;&#10;&#10;    // Font sizes&#10;    constexpr int TIME_FONT_SIZE = 24;&#10;    constexpr int STATUS_FONT_SIZE = 14;&#10;    constexpr int SESSION_FONT_SIZE = 12;&#10;    constexpr int BUTTON_FONT_SIZE = 11;&#10;&#10;    // Progress bar positioning&#10;    constexpr int TIME_LABEL_Y_OFFSET = 90;&#10;}&#10;&#10;PomodoroTimer::PomodoroTimer(QWidget *parent)&#10;    : QWidget(parent)&#10;    , m_timer(new QTimer(this))&#10;    , m_trayManager(std::make_unique&lt;SystemTrayManager&gt;(this))&#10;    , m_keyboardShortcuts(std::make_unique&lt;KeyboardShortcuts&gt;(this))&#10;    , m_notificationManager(std::make_unique&lt;NotificationManager&gt;(this))&#10;{&#10;    loadSettings();&#10;    setupUI();&#10;    setupConnections();&#10;    resetTimerState();&#10;    updateDisplay();&#10;&#10;    // Setup manager connections&#10;    m_notificationManager-&gt;setSystemTrayManager(m_trayManager.get());&#10;    m_notificationManager-&gt;setNotificationsEnabled(m_showNotifications);&#10;    m_trayManager-&gt;show();&#10;}&#10;&#10;PomodoroTimer::~PomodoroTimer()&#10;{&#10;    saveSettings();&#10;}&#10;&#10;void PomodoroTimer::setupUI()&#10;{&#10;    setFixedSize(WINDOW_WIDTH, WINDOW_HEIGHT);&#10;&#10;    m_mainFrame = new QFrame(this);&#10;    m_circularProgress = new CircularProgressBar(m_mainFrame);&#10;    m_circularProgress-&gt;setFixedSize(PROGRESS_BAR_SIZE, PROGRESS_BAR_SIZE);&#10;&#10;    createLabels();&#10;    createButtons();&#10;    createLayouts();&#10;    applyStyles();&#10;    updateButtonStates();&#10;}&#10;&#10;void PomodoroTimer::createLabels()&#10;{&#10;    // Time display label&#10;    m_timeLabel = new QLabel(&quot;25:00&quot;, m_circularProgress);&#10;    m_timeLabel-&gt;setAlignment(Qt::AlignCenter);&#10;    m_timeLabel-&gt;resize(PROGRESS_BAR_SIZE, 40);&#10;    m_timeLabel-&gt;move(0, TIME_LABEL_Y_OFFSET);&#10;&#10;    // Status indicator label&#10;    m_statusLabel = new QLabel(&quot;Ready to Focus&quot;, m_mainFrame);&#10;    m_statusLabel-&gt;setAlignment(Qt::AlignCenter);&#10;&#10;    // Session progress label&#10;    m_sessionLabel = new QLabel(&quot;Session 1 of 4&quot;, m_mainFrame);&#10;    m_sessionLabel-&gt;setAlignment(Qt::AlignCenter);&#10;}&#10;&#10;void PomodoroTimer::createButtons()&#10;{&#10;    m_startButton = new QPushButton(&quot;Start&quot;, m_mainFrame);&#10;    m_pauseButton = new QPushButton(&quot;Pause&quot;, m_mainFrame);&#10;    m_resetButton = new QPushButton(&quot;Reset&quot;, m_mainFrame);&#10;    m_settingsButton = new QPushButton(&quot;Settings&quot;, m_mainFrame);&#10;    m_skipButton = new QPushButton(&quot;Skip&quot;, m_mainFrame);&#10;    m_statsButton = new QPushButton(&quot;Statistics&quot;, m_mainFrame);&#10;&#10;    // Set button sizes&#10;    constexpr QSize mainButtonSize(MAIN_BUTTON_WIDTH, MAIN_BUTTON_HEIGHT);&#10;    constexpr QSize smallButtonSize(SMALL_BUTTON_WIDTH, SMALL_BUTTON_HEIGHT);&#10;&#10;    m_startButton-&gt;setFixedSize(mainButtonSize);&#10;    m_pauseButton-&gt;setFixedSize(mainButtonSize);&#10;    m_resetButton-&gt;setFixedSize(mainButtonSize);&#10;    m_settingsButton-&gt;setFixedSize(mainButtonSize);&#10;    m_skipButton-&gt;setFixedSize(smallButtonSize);&#10;    m_statsButton-&gt;setFixedSize(smallButtonSize);&#10;}&#10;&#10;void PomodoroTimer::createLayouts()&#10;{&#10;    // Progress bar layout&#10;    auto progressLayout = new QVBoxLayout();&#10;    progressLayout-&gt;addWidget(m_circularProgress, 0, Qt::AlignCenter);&#10;&#10;    // Main control buttons layout&#10;    auto buttonLayout = new QHBoxLayout();&#10;    buttonLayout-&gt;setSpacing(LAYOUT_SPACING);&#10;    buttonLayout-&gt;addWidget(m_startButton);&#10;    buttonLayout-&gt;addWidget(m_pauseButton);&#10;    buttonLayout-&gt;addWidget(m_resetButton);&#10;&#10;    // Header layout with settings button&#10;    auto headerLayout = new QHBoxLayout();&#10;    headerLayout-&gt;addStretch();&#10;    headerLayout-&gt;addWidget(m_settingsButton);&#10;&#10;    // Extra buttons layout&#10;    auto extraButtonLayout = new QHBoxLayout();&#10;    extraButtonLayout-&gt;setSpacing(LAYOUT_SPACING);&#10;    extraButtonLayout-&gt;addStretch();&#10;    extraButtonLayout-&gt;addWidget(m_skipButton);&#10;    extraButtonLayout-&gt;addWidget(m_statsButton);&#10;    extraButtonLayout-&gt;addStretch();&#10;&#10;    // Main layout assembly&#10;    auto mainLayout = new QVBoxLayout();&#10;    mainLayout-&gt;addLayout(headerLayout);&#10;    mainLayout-&gt;addSpacing(5);&#10;    mainLayout-&gt;addWidget(m_statusLabel);&#10;    mainLayout-&gt;addSpacing(15);&#10;    mainLayout-&gt;addLayout(progressLayout);&#10;    mainLayout-&gt;addSpacing(15);&#10;    mainLayout-&gt;addWidget(m_sessionLabel);&#10;    mainLayout-&gt;addSpacing(20);&#10;    mainLayout-&gt;addLayout(buttonLayout);&#10;    mainLayout-&gt;addSpacing(15);&#10;    mainLayout-&gt;addLayout(extraButtonLayout);&#10;    mainLayout-&gt;setContentsMargins(LAYOUT_MARGIN, LAYOUT_MARGIN, LAYOUT_MARGIN, LAYOUT_MARGIN);&#10;&#10;    m_mainFrame-&gt;setLayout(mainLayout);&#10;&#10;    // Frame layout&#10;    auto frameLayout = new QVBoxLayout();&#10;    frameLayout-&gt;addWidget(m_mainFrame);&#10;    frameLayout-&gt;setContentsMargins(0, 0, 0, 0);&#10;    setLayout(frameLayout);&#10;}&#10;&#10;void PomodoroTimer::applyStyles() const {&#10;    QFont timeFont = m_timeLabel-&gt;font();&#10;    timeFont.setPointSize(TIME_FONT_SIZE);&#10;    timeFont.setBold(true);&#10;    m_timeLabel-&gt;setFont(timeFont);&#10;&#10;    QFont statusFont = m_statusLabel-&gt;font();&#10;    statusFont.setPointSize(STATUS_FONT_SIZE);&#10;    m_statusLabel-&gt;setFont(statusFont);&#10;&#10;    QFont sessionFont = m_sessionLabel-&gt;font();&#10;    sessionFont.setPointSize(SESSION_FONT_SIZE);&#10;    m_sessionLabel-&gt;setFont(sessionFont);&#10;&#10;    QFont buttonFont;&#10;    buttonFont.setPointSize(BUTTON_FONT_SIZE);&#10;&#10;    const auto buttons = {m_startButton, m_pauseButton, m_resetButton,&#10;                         m_settingsButton, m_skipButton, m_statsButton};&#10;    for (auto* button : buttons) {&#10;        if (button) button-&gt;setFont(buttonFont);&#10;    }&#10;}&#10;&#10;void PomodoroTimer::setupConnections()&#10;{&#10;    // Timer connections&#10;    connect(m_timer, &amp;QTimer::timeout, this, &amp;PomodoroTimer::onUpdateTimer);&#10;&#10;    // Button connections&#10;    connect(m_startButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onStartTimer);&#10;    connect(m_pauseButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onPauseTimer);&#10;    connect(m_resetButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onResetTimer);&#10;    connect(m_settingsButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onShowSettings);&#10;    connect(m_skipButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onSkipSession);&#10;    connect(m_statsButton, &amp;QPushButton::clicked, this, &amp;PomodoroTimer::onShowStatistics);&#10;&#10;    // System tray connections&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::showMainWindow, this, &amp;PomodoroTimer::onToggleVisibility);&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::startPauseRequested, this, [this]() {&#10;        m_isRunning ? onPauseTimer() : onStartTimer();&#10;    });&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::resetRequested, this, &amp;PomodoroTimer::onResetTimer);&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::skipRequested, this, &amp;PomodoroTimer::onSkipSession);&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::settingsRequested, this, &amp;PomodoroTimer::onShowSettings);&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::statisticsRequested, this, &amp;PomodoroTimer::onShowStatistics);&#10;    connect(m_trayManager.get(), &amp;SystemTrayManager::quitRequested, qApp, &amp;QCoreApplication::quit);&#10;&#10;    // Keyboard shortcuts connections&#10;    connect(m_keyboardShortcuts.get(), &amp;KeyboardShortcuts::startPauseRequested, this, [this]() {&#10;        m_isRunning ? onPauseTimer() : onStartTimer();&#10;    });&#10;    connect(m_keyboardShortcuts.get(), &amp;KeyboardShortcuts::pauseRequested, this, &amp;PomodoroTimer::onPauseTimer);&#10;    connect(m_keyboardShortcuts.get(), &amp;KeyboardShortcuts::resetRequested, this, &amp;PomodoroTimer::onResetTimer);&#10;    connect(m_keyboardShortcuts.get(), &amp;KeyboardShortcuts::settingsRequested, this, &amp;PomodoroTimer::onShowSettings);&#10;    connect(m_keyboardShortcuts.get(), &amp;KeyboardShortcuts::skipRequested, this, &amp;PomodoroTimer::onSkipSession);&#10;}&#10;&#10;// Timer control methods&#10;void PomodoroTimer::onStartTimer()&#10;{&#10;    if (m_isRunning) return;&#10;&#10;    m_isRunning = true;&#10;    m_sessionStartTime = QDateTime::currentDateTime();&#10;    m_timer-&gt;start(TIMER_INTERVAL_MS);&#10;&#10;    m_statusLabel-&gt;setText(TimerStateHelper::getStatusMessage(m_currentState, true));&#10;    updateButtonStates();&#10;    updateDisplay();&#10;}&#10;&#10;void PomodoroTimer::onPauseTimer()&#10;{&#10;    if (!m_isRunning) return;&#10;&#10;    m_timer-&gt;stop();&#10;    m_isRunning = false;&#10;    m_statusLabel-&gt;setText(&quot;⏸ Paused&quot;);&#10;    updateButtonStates();&#10;    updateDisplay();&#10;}&#10;&#10;void PomodoroTimer::onResetTimer()&#10;{&#10;    m_timer-&gt;stop();&#10;    m_isRunning = false;&#10;    resetTimerState();&#10;    updateDisplay();&#10;    updateButtonStates();&#10;}&#10;&#10;void PomodoroTimer::onUpdateTimer()&#10;{&#10;    --m_currentTime;&#10;    updateDisplay();&#10;&#10;    if (m_currentTime &lt;= 0) {&#10;        onTimerFinished();&#10;    }&#10;}&#10;&#10;void PomodoroTimer::onTimerFinished()&#10;{&#10;    m_timer-&gt;stop();&#10;    m_isRunning = false;&#10;&#10;    // Update statistics&#10;    const QDateTime now = QDateTime::currentDateTime();&#10;    const int sessionDuration = static_cast&lt;int&gt;(m_sessionStartTime.secsTo(now));&#10;&#10;    if (m_currentState == TimerState::Work) {&#10;        m_totalWorkTime += sessionDuration;&#10;        m_totalSessions++;&#10;        m_completedSessions++;&#10;    } else {&#10;        m_totalBreakTime += sessionDuration;&#10;    }&#10;&#10;    // Determine next state and show notifications&#10;    QString message, nextAction;&#10;    if (m_currentState == TimerState::Work) {&#10;        message = &quot; Focus session completed!&quot;;&#10;&#10;        const bool isLongBreakTime = (m_completedSessions % SESSIONS_BEFORE_LONG_BREAK == 0);&#10;        updateTimerState(isLongBreakTime ? TimerState::LongBreak : TimerState::ShortBreak);&#10;        nextAction = isLongBreakTime ? &quot;Time for a long break! ‍♀️&quot; : &quot;Take a short break! ☕&quot;;&#10;    } else {&#10;        message = &quot;Break time finished!&quot;;&#10;        nextAction = &quot;Ready to focus again? &quot;;&#10;        updateTimerState(TimerState::Work);&#10;    }&#10;&#10;    m_notificationManager-&gt;showNotification(message + &quot; &quot; + nextAction);&#10;    onResetTimer();&#10;&#10;    // Auto-start if enabled&#10;    const bool shouldAutoStart = (m_currentState != TimerState::Work &amp;&amp; m_autoStartBreaks) ||&#10;                                (m_currentState == TimerState::Work &amp;&amp; m_autoStartWork);&#10;    if (shouldAutoStart) {&#10;        QTimer::singleShot(AUTO_START_DELAY_MS, this, &amp;PomodoroTimer::onStartTimer);&#10;    }&#10;&#10;    saveSettings();&#10;}&#10;&#10;// Helper methods&#10;void PomodoroTimer::resetTimerState()&#10;{&#10;    m_currentTime = TimerStateHelper::getDurationForState(m_currentState, m_workDuration, m_shortBreakDuration, m_longBreakDuration);&#10;    m_totalDuration = m_currentTime;&#10;    m_statusLabel-&gt;setText(TimerStateHelper::getStatusMessage(m_currentState, false));&#10;}&#10;&#10;void PomodoroTimer::updateTimerState(TimerState newState)&#10;{&#10;    m_currentState = newState;&#10;}&#10;&#10;QString PomodoroTimer::formatTime(int seconds) {&#10;  const int minutes = seconds / 60;&#10;  const int secs = seconds % 60;&#10;  return QString(&quot;%1:%2&quot;)&#10;      .arg(minutes, 2, 10, QChar('0'))&#10;      .arg(secs, 2, 10, QChar('0'));&#10;}&#10;void PomodoroTimer::needsDisplayUpdate() {}&#10;&#10;void PomodoroTimer::updateDisplay()&#10;{&#10;    m_timeLabel-&gt;setText(formatTime(m_currentTime));&#10;&#10;    const int progress = m_totalDuration &gt; 0 ?&#10;        ((m_totalDuration - m_currentTime) * 100) / m_totalDuration : 0;&#10;    m_circularProgress-&gt;setValue(progress);&#10;&#10;    updateSessionCounter();&#10;    updateWindowTitle();&#10;&#10;    // Update system tray&#10;    const int currentSession = (m_completedSessions % SESSIONS_BEFORE_LONG_BREAK) + 1;&#10;    m_trayManager-&gt;updateTooltip(m_currentState, m_isRunning, formatTime(m_currentTime),&#10;                                currentSession, SESSIONS_BEFORE_LONG_BREAK);&#10;}&#10;&#10;void PomodoroTimer::updateSessionCounter() const {&#10;    const int currentSession = (m_completedSessions % SESSIONS_BEFORE_LONG_BREAK) + 1;&#10;    m_sessionLabel-&gt;setText(QString(&quot;Session %1 of %2&quot;)&#10;                           .arg(currentSession)&#10;                           .arg(SESSIONS_BEFORE_LONG_BREAK));&#10;}&#10;&#10;void PomodoroTimer::updateButtonStates() const {&#10;    m_startButton-&gt;setEnabled(!m_isRunning);&#10;    m_pauseButton-&gt;setEnabled(m_isRunning);&#10;&#10;    const bool shouldShowReset = m_isRunning || m_currentTime &lt; m_totalDuration;&#10;    m_resetButton-&gt;setVisible(shouldShowReset);&#10;    m_resetButton-&gt;setEnabled(true);&#10;&#10;    m_skipButton-&gt;setEnabled(m_isRunning);&#10;    m_skipButton-&gt;setVisible(m_isRunning);&#10;&#10;    // Force layout update&#10;    if (m_mainFrame &amp;&amp; m_mainFrame-&gt;layout()) {&#10;        m_mainFrame-&gt;layout()-&gt;update();&#10;        m_mainFrame-&gt;updateGeometry();&#10;    }&#10;}&#10;&#10;void PomodoroTimer::updateWindowTitle() {&#10;  const QString timeRemaining = formatTime(m_currentTime);&#10;  const QString emoji = TimerStateHelper::getStateEmoji(m_currentState);&#10;&#10;  QString title;&#10;  if (m_isRunning) {&#10;    const QString stateText =&#10;        (m_currentState == TimerState::Work) ? &quot;Focus&quot; : &quot;Break&quot;;&#10;    title = QString(&quot;%1 %2: %3&quot;).arg(emoji, stateText, timeRemaining);&#10;  } else {&#10;    title = &quot; Pomodoro Timer&quot;;&#10;  }&#10;&#10;  setWindowTitle(title);&#10;}&#10;void PomodoroTimer::updateTrayTooltip() {}&#10;&#10;void PomodoroTimer::onShowSettings()&#10;{&#10;    SettingsDialog dialog(this);&#10;&#10;    dialog.setWorkDuration(m_workDuration / 60);&#10;    dialog.setShortBreakDuration(m_shortBreakDuration / 60);&#10;    dialog.setLongBreakDuration(m_longBreakDuration / 60);&#10;    dialog.setAutoStartBreaks(m_autoStartBreaks);&#10;    dialog.setAutoStartWork(m_autoStartWork);&#10;    dialog.setMinimizeToTray(m_minimizeToTray);&#10;    dialog.setShowNotifications(m_showNotifications);&#10;&#10;    if (dialog.exec() == QDialog::Accepted) {&#10;        m_workDuration = dialog.workDuration() * 60;&#10;        m_shortBreakDuration = dialog.shortBreakDuration() * 60;&#10;        m_longBreakDuration = dialog.longBreakDuration() * 60;&#10;        m_autoStartBreaks = dialog.autoStartBreaks();&#10;        m_autoStartWork = dialog.autoStartWork();&#10;        m_minimizeToTray = dialog.minimizeToTray();&#10;        m_showNotifications = dialog.showNotifications();&#10;&#10;        saveSettings();&#10;        onResetTimer();&#10;    }&#10;}&#10;&#10;void PomodoroTimer::onSkipSession()&#10;{&#10;    if (m_isRunning) {&#10;        onTimerFinished();&#10;    }&#10;}&#10;&#10;void PomodoroTimer::onShowStatistics()&#10;{&#10;    StatisticsDialog dialog(this);&#10;    dialog.setStatistics(m_totalSessions, m_totalWorkTime, m_totalBreakTime);&#10;    dialog.exec();&#10;}&#10;&#10;void PomodoroTimer::onToggleVisibility()&#10;{&#10;    if (isVisible()) {&#10;        hide();&#10;    } else {&#10;        show();&#10;        raise();&#10;        activateWindow();&#10;    }&#10;}&#10;&#10;void PomodoroTimer::loadSettings()&#10;{&#10;    QSettings settings;&#10;    m_workDuration = settings.value(&quot;workDuration&quot;, DEFAULT_WORK_DURATION).toInt();&#10;    m_shortBreakDuration = settings.value(&quot;shortBreakDuration&quot;, DEFAULT_SHORT_BREAK).toInt();&#10;    m_longBreakDuration = settings.value(&quot;longBreakDuration&quot;, DEFAULT_LONG_BREAK).toInt();&#10;    m_autoStartBreaks = settings.value(&quot;autoStartBreaks&quot;, false).toBool();&#10;    m_autoStartWork = settings.value(&quot;autoStartWork&quot;, false).toBool();&#10;    m_minimizeToTray = settings.value(&quot;minimizeToTray&quot;, true).toBool();&#10;    m_showNotifications = settings.value(&quot;showNotifications&quot;, true).toBool();&#10;    m_totalSessions = settings.value(&quot;totalSessions&quot;, 0).toInt();&#10;    m_totalWorkTime = settings.value(&quot;totalWorkTime&quot;, 0).toInt();&#10;    m_totalBreakTime = settings.value(&quot;totalBreakTime&quot;, 0).toInt();&#10;}&#10;&#10;void PomodoroTimer::saveSettings() const {&#10;    QSettings settings;&#10;    settings.setValue(&quot;workDuration&quot;, m_workDuration);&#10;    settings.setValue(&quot;shortBreakDuration&quot;, m_shortBreakDuration);&#10;    settings.setValue(&quot;longBreakDuration&quot;, m_longBreakDuration);&#10;    settings.setValue(&quot;autoStartBreaks&quot;, m_autoStartBreaks);&#10;    settings.setValue(&quot;autoStartWork&quot;, m_autoStartWork);&#10;    settings.setValue(&quot;minimizeToTray&quot;, m_minimizeToTray);&#10;    settings.setValue(&quot;showNotifications&quot;, m_showNotifications);&#10;    settings.setValue(&quot;totalSessions&quot;, m_totalSessions);&#10;    settings.setValue(&quot;totalWorkTime&quot;, m_totalWorkTime);&#10;    settings.setValue(&quot;totalBreakTime&quot;, m_totalBreakTime);&#10;}&#10;&#10;void PomodoroTimer::keyPressEvent(QKeyEvent *event)&#10;{&#10;    if (event-&gt;key() == Qt::Key_Escape) {&#10;        hide();&#10;    }&#10;    QWidget::keyPressEvent(event);&#10;}&#10;&#10;void PomodoroTimer::closeEvent(QCloseEvent *event)&#10;{&#10;    if (m_trayManager &amp;&amp; m_trayManager-&gt;isVisible()) {&#10;        hide();&#10;        event-&gt;ignore();&#10;&#10;        static bool firstHide = true;&#10;        if (firstHide) {&#10;            m_notificationManager-&gt;showNotification(&quot;Application was minimized to tray. Click the tray icon to show again.&quot;);&#10;            firstHide = false;&#10;        }&#10;    } else {&#10;        saveSettings();&#10;        event-&gt;accept();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/ui/PomodoroTimer.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/ui/PomodoroTimer.h" />
              <option name="originalContent" value="#ifndef POMODOROTIMER_H&#10;#define POMODOROTIMER_H&#10;&#10;#include &lt;QTimer&gt;&#10;#include &lt;QLabel&gt;&#10;#include &lt;QPushButton&gt;&#10;#include &lt;QFrame&gt;&#10;#include &lt;QDateTime&gt;&#10;#include &lt;memory&gt;&#10;#include &quot;core/TimerState.h&quot;&#10;&#10;// Forward declarations&#10;class CircularProgressBar;&#10;class SettingsDialog;&#10;class StatisticsDialog;&#10;class SystemTrayManager;&#10;class KeyboardShortcuts;&#10;class NotificationManager;&#10;&#10;class PomodoroTimer : public QWidget&#10;{&#10;    Q_OBJECT&#10;&#10;public:&#10;    explicit PomodoroTimer(QWidget *parent = nullptr);&#10;    ~PomodoroTimer() override;&#10;&#10;    // Timer configuration constants&#10;    static constexpr int DEFAULT_WORK_DURATION = 1500;      // 25 minutes in seconds&#10;    static constexpr int DEFAULT_SHORT_BREAK = 300;         // 5 minutes in seconds&#10;    static constexpr int DEFAULT_LONG_BREAK = 900;          // 15 minutes in seconds&#10;    static constexpr int SESSIONS_BEFORE_LONG_BREAK = 4;&#10;    static constexpr int TIMER_INTERVAL_MS = 1000;&#10;    static constexpr int AUTO_START_DELAY_MS = 3000;&#10;&#10;protected:&#10;    void keyPressEvent(QKeyEvent *event) override;&#10;    void closeEvent(QCloseEvent *event) override;&#10;&#10;private slots:&#10;    // Timer control slots&#10;    void onStartTimer();&#10;    void onPauseTimer();&#10;    void onResetTimer();&#10;    void onUpdateTimer();&#10;    void onTimerFinished();&#10;&#10;    // UI interaction slots&#10;    void onShowSettings();&#10;    void onSkipSession();&#10;    void onShowStatistics();&#10;    void onToggleVisibility();&#10;&#10;private:&#10;    // Setup methods&#10;    void setupUI();&#10;    void setupConnections();&#10;&#10;    // UI creation helpers&#10;    void createLabels();&#10;    void createButtons();&#10;    void createLayouts();&#10;    void applyStyles() const;&#10;&#10;    // Settings management&#10;    void loadSettings();&#10;    void saveSettings() const;&#10;&#10;    // Timer state management&#10;    void resetTimerState();&#10;    void updateTimerState(TimerState newState);&#10;&#10;    // Display update methods - optimized to avoid unnecessary updates&#10;    void updateDisplay();&#10;    void updateSessionCounter() const;&#10;    void updateButtonStates() const;&#10;    void updateWindowTitle();&#10;    static void updateTrayTooltip();&#10;&#10;    // Utility methods&#10;    static QString formatTime(int seconds);&#10;    static void needsDisplayUpdate();&#10;&#10;    // UI elements - use raw pointers for Qt objects with parent ownership&#10;    QTimer *m_timer;&#10;    QLabel *m_timeLabel{nullptr};&#10;    QLabel *m_statusLabel{nullptr};&#10;    QLabel *m_sessionLabel{nullptr};&#10;    QPushButton *m_startButton{nullptr};&#10;    QPushButton *m_pauseButton{nullptr};&#10;    QPushButton *m_resetButton{nullptr};&#10;    QPushButton *m_settingsButton{nullptr};&#10;    QPushButton *m_skipButton{nullptr};&#10;    QPushButton *m_statsButton{nullptr};&#10;    CircularProgressBar *m_circularProgress{nullptr};&#10;    QFrame *m_mainFrame{nullptr};&#10;&#10;    // Managers - keep as unique_ptr for complex objects&#10;    std::unique_ptr&lt;SystemTrayManager&gt; m_trayManager;&#10;    std::unique_ptr&lt;KeyboardShortcuts&gt; m_keyboardShortcuts;&#10;    std::unique_ptr&lt;NotificationManager&gt; m_notificationManager;&#10;&#10;    // Timer state&#10;    int m_currentTime{0};&#10;    int m_totalDuration{0};&#10;    TimerState m_currentState{TimerState::Work};&#10;    int m_completedSessions{0};&#10;    bool m_isRunning{false};&#10;&#10;    // Cache for reducing string operations&#10;    mutable QString m_cachedTimeString;&#10;    mutable int m_lastFormattedTime{-1};&#10;&#10;    // Settings&#10;    int m_workDuration{DEFAULT_WORK_DURATION};&#10;    int m_shortBreakDuration{DEFAULT_SHORT_BREAK};&#10;    int m_longBreakDuration{DEFAULT_LONG_BREAK};&#10;    bool m_autoStartBreaks{false};&#10;    bool m_autoStartWork{false};&#10;    bool m_minimizeToTray{true};&#10;    bool m_showNotifications{true};&#10;&#10;    // Statistics&#10;    int m_totalSessions{0};&#10;    int m_totalWorkTime{0};&#10;    int m_totalBreakTime{0};&#10;    QDateTime m_sessionStartTime;&#10;&#10;    // Update tracking to prevent unnecessary redraws&#10;    bool m_needsButtonUpdate{true};&#10;    bool m_needsSessionUpdate{true};&#10;    QString m_lastWindowTitle;&#10;};&#10;&#10;#endif // POMODOROTIMER_H&#10;" />
              <option name="updatedContent" value="#ifndef POMODOROTIMER_H&#10;#define POMODOROTIMER_H&#10;&#10;#include &lt;QTimer&gt;&#10;#include &lt;QLabel&gt;&#10;#include &lt;QPushButton&gt;&#10;#include &lt;QFrame&gt;&#10;#include &lt;QDateTime&gt;&#10;#include &lt;memory&gt;&#10;#include &quot;TimerState.h&quot;&#10;&#10;// Forward declarations&#10;class CircularProgressBar;&#10;class SettingsDialog;&#10;class StatisticsDialog;&#10;class SystemTrayManager;&#10;class KeyboardShortcuts;&#10;class NotificationManager;&#10;&#10;class PomodoroTimer : public QWidget&#10;{&#10;    Q_OBJECT&#10;&#10;public:&#10;    explicit PomodoroTimer(QWidget *parent = nullptr);&#10;    ~PomodoroTimer() override;&#10;&#10;    // Timer configuration constants&#10;    static constexpr int DEFAULT_WORK_DURATION = 1500;      // 25 minutes in seconds&#10;    static constexpr int DEFAULT_SHORT_BREAK = 300;         // 5 minutes in seconds&#10;    static constexpr int DEFAULT_LONG_BREAK = 900;          // 15 minutes in seconds&#10;    static constexpr int SESSIONS_BEFORE_LONG_BREAK = 4;&#10;    static constexpr int TIMER_INTERVAL_MS = 1000;&#10;    static constexpr int AUTO_START_DELAY_MS = 3000;&#10;&#10;protected:&#10;    void keyPressEvent(QKeyEvent *event) override;&#10;    void closeEvent(QCloseEvent *event) override;&#10;&#10;private slots:&#10;    // Timer control slots&#10;    void onStartTimer();&#10;    void onPauseTimer();&#10;    void onResetTimer();&#10;    void onUpdateTimer();&#10;    void onTimerFinished();&#10;&#10;    // UI interaction slots&#10;    void onShowSettings();&#10;    void onSkipSession();&#10;    void onShowStatistics();&#10;    void onToggleVisibility();&#10;&#10;private:&#10;    // Setup methods&#10;    void setupUI();&#10;    void setupConnections();&#10;&#10;    // UI creation helpers&#10;    void createLabels();&#10;    void createButtons();&#10;    void createLayouts();&#10;    void applyStyles() const;&#10;&#10;    // Settings management&#10;    void loadSettings();&#10;    void saveSettings() const;&#10;&#10;    // Timer state management&#10;    void resetTimerState();&#10;    void updateTimerState(TimerState newState);&#10;&#10;    // Display update methods - optimized to avoid unnecessary updates&#10;    void updateDisplay();&#10;    void updateSessionCounter() const;&#10;    void updateButtonStates() const;&#10;    void updateWindowTitle();&#10;    static void updateTrayTooltip();&#10;&#10;    // Utility methods&#10;    static QString formatTime(int seconds);&#10;    static void needsDisplayUpdate();&#10;&#10;    // UI elements - use raw pointers for Qt objects with parent ownership&#10;    QTimer *m_timer;&#10;    QLabel *m_timeLabel{nullptr};&#10;    QLabel *m_statusLabel{nullptr};&#10;    QLabel *m_sessionLabel{nullptr};&#10;    QPushButton *m_startButton{nullptr};&#10;    QPushButton *m_pauseButton{nullptr};&#10;    QPushButton *m_resetButton{nullptr};&#10;    QPushButton *m_settingsButton{nullptr};&#10;    QPushButton *m_skipButton{nullptr};&#10;    QPushButton *m_statsButton{nullptr};&#10;    CircularProgressBar *m_circularProgress{nullptr};&#10;    QFrame *m_mainFrame{nullptr};&#10;&#10;    // Managers - keep as unique_ptr for complex objects&#10;    std::unique_ptr&lt;SystemTrayManager&gt; m_trayManager;&#10;    std::unique_ptr&lt;KeyboardShortcuts&gt; m_keyboardShortcuts;&#10;    std::unique_ptr&lt;NotificationManager&gt; m_notificationManager;&#10;&#10;    // Timer state&#10;    int m_currentTime{0};&#10;    int m_totalDuration{0};&#10;    TimerState m_currentState{TimerState::Work};&#10;    int m_completedSessions{0};&#10;    bool m_isRunning{false};&#10;&#10;    // Cache for reducing string operations&#10;    mutable QString m_cachedTimeString;&#10;    mutable int m_lastFormattedTime{-1};&#10;&#10;    // Settings&#10;    int m_workDuration{DEFAULT_WORK_DURATION};&#10;    int m_shortBreakDuration{DEFAULT_SHORT_BREAK};&#10;    int m_longBreakDuration{DEFAULT_LONG_BREAK};&#10;    bool m_autoStartBreaks{false};&#10;    bool m_autoStartWork{false};&#10;    bool m_minimizeToTray{true};&#10;    bool m_showNotifications{true};&#10;&#10;    // Statistics&#10;    int m_totalSessions{0};&#10;    int m_totalWorkTime{0};&#10;    int m_totalBreakTime{0};&#10;    QDateTime m_sessionStartTime;&#10;&#10;    // Update tracking to prevent unnecessary redraws&#10;    bool m_needsButtonUpdate{true};&#10;    bool m_needsSessionUpdate{true};&#10;    QString m_lastWindowTitle;&#10;};&#10;&#10;#endif // POMODOROTIMER_H" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>